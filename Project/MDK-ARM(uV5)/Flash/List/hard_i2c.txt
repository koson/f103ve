; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\hard_i2c.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\hard_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\SPI -I..\..\User\Driver\ADC -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Modules\Modules_mpu6050 -I..\..\User\Modules\Modules_nrf24L01 -I..\..\User\Modules\Modules_hmc5883 -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Modules\Modules_oled -I..\..\User\Driver\STMFLASH -I..\..\User\Modules\Modules_ms5611 -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\GPS -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Heigh -IC:\Users\Administrator\Desktop\Ama\¸ßÎ»ME421\Project\MDK-ARM(uV5)\RTE -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\hard_i2c.crf ..\..\User\Driver\IIC\hard_i2c.c]
                          THUMB

                          AREA ||i.I2C1_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C1_ER_IRQHandler PROC
;;;43     
;;;44     void I2C1_ER_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46         i2c_er_handler();
000002  f7fffffe          BL       i2c_er_handler
;;;47     }
000006  bd10              POP      {r4,pc}
;;;48     
                          ENDP


                          AREA ||i.I2C1_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C1_EV_IRQHandler PROC
;;;48     
;;;49     void I2C1_EV_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;50     {
;;;51         i2c_ev_handler();
000002  f7fffffe          BL       i2c_ev_handler
;;;52     }
000006  bd10              POP      {r4,pc}
;;;53     
                          ENDP


                          AREA ||i.I2C2_ER_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C2_ER_IRQHandler PROC
;;;53     
;;;54     void I2C2_ER_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56         i2c_er_handler();
000002  f7fffffe          BL       i2c_er_handler
;;;57     }
000006  bd10              POP      {r4,pc}
;;;58     
                          ENDP


                          AREA ||i.I2C2_EV_IRQHandler||, CODE, READONLY, ALIGN=1

                  I2C2_EV_IRQHandler PROC
;;;58     
;;;59     void I2C2_EV_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;60     {
;;;61         i2c_ev_handler();
000002  f7fffffe          BL       i2c_ev_handler
;;;62     }
000006  bd10              POP      {r4,pc}
;;;63     
                          ENDP


                          AREA ||i.i2cGetErrorCounter||, CODE, READONLY, ALIGN=2

                  i2cGetErrorCounter PROC
;;;344    
;;;345    uint16_t i2cGetErrorCounter(void)
000000  4801              LDR      r0,|L5.8|
;;;346    {
;;;347        return i2cErrorCount;
000002  8800              LDRH     r0,[r0,#0]  ; i2cErrorCount
;;;348    }
000004  4770              BX       lr
;;;349    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      i2cErrorCount

                          AREA ||i.i2cHandleHardwareFailure||, CODE, READONLY, ALIGN=2

                  i2cHandleHardwareFailure PROC
;;;77     
;;;78     static bool i2cHandleHardwareFailure(void)
000000  b510              PUSH     {r4,lr}
;;;79     {
;;;80         i2cErrorCount++;
000002  4805              LDR      r0,|L6.24|
000004  8800              LDRH     r0,[r0,#0]  ; i2cErrorCount
000006  1c40              ADDS     r0,r0,#1
000008  4903              LDR      r1,|L6.24|
00000a  8008              STRH     r0,[r1,#0]
;;;81         // reinit peripheral + clock out garbage
;;;82         i2cInit(I2Cx_index);
00000c  4803              LDR      r0,|L6.28|
00000e  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
000010  f7fffffe          BL       i2cInit
;;;83         return FALSE;
000014  2000              MOVS     r0,#0
;;;84     }
000016  bd10              POP      {r4,pc}
;;;85     
                          ENDP

                  |L6.24|
                          DCD      i2cErrorCount
                  |L6.28|
                          DCD      I2Cx_index

                          AREA ||i.i2cInit||, CODE, READONLY, ALIGN=2

                  i2cInit PROC
;;;302    
;;;303    void i2cInit(I2CDevice index)
000000  b510              PUSH     {r4,lr}
;;;304    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;305        NVIC_InitTypeDef nvic;
;;;306        I2C_InitTypeDef i2c;
;;;307    
;;;308        if (index > I2CDEV_MAX)
000006  2c01              CMP      r4,#1
000008  dd00              BLE      |L7.12|
;;;309            index = I2CDEV_MAX;
00000a  2401              MOVS     r4,#1
                  |L7.12|
;;;310    
;;;311        // Turn on peripheral clock, save device and index
;;;312        I2Cx = i2cHardwareMap[index].dev;
00000c  eb040084          ADD      r0,r4,r4,LSL #2
000010  492c              LDR      r1,|L7.196|
000012  f8510020          LDR      r0,[r1,r0,LSL #2]
000016  492c              LDR      r1,|L7.200|
000018  6008              STR      r0,[r1,#0]  ; I2Cx
;;;313        I2Cx_index = index;
00001a  482c              LDR      r0,|L7.204|
00001c  7004              STRB     r4,[r0,#0]
;;;314        RCC_APB1PeriphClockCmd(i2cHardwareMap[index].peripheral, ENABLE);
00001e  eb040184          ADD      r1,r4,r4,LSL #2
000022  4a28              LDR      r2,|L7.196|
000024  eb020181          ADD      r1,r2,r1,LSL #2
000028  6908              LDR      r0,[r1,#0x10]
00002a  2101              MOVS     r1,#1
00002c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;315    
;;;316        // clock out stuff to make sure slaves arent stuck
;;;317        // This will also configure GPIO as AF_OD at the end
;;;318        i2cUnstick();
000030  f7fffffe          BL       i2cUnstick
;;;319    
;;;320        // Init I2C peripheral
;;;321        I2C_DeInit(I2Cx);
000034  4824              LDR      r0,|L7.200|
000036  6800              LDR      r0,[r0,#0]  ; I2Cx
000038  f7fffffe          BL       I2C_DeInit
;;;322        I2C_StructInit(&i2c);
00003c  a801              ADD      r0,sp,#4
00003e  f7fffffe          BL       I2C_StructInit
;;;323    
;;;324        I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);               // Enable EVT and ERR interrupts - they are enabled by the first request
000042  2200              MOVS     r2,#0
000044  f44f7140          MOV      r1,#0x300
000048  481f              LDR      r0,|L7.200|
00004a  6800              LDR      r0,[r0,#0]  ; I2Cx
00004c  f7fffffe          BL       I2C_ITConfig
;;;325        i2c.I2C_Mode = I2C_Mode_I2C;
000050  2000              MOVS     r0,#0
000052  f8ad0008          STRH     r0,[sp,#8]
;;;326        i2c.I2C_DutyCycle = I2C_DutyCycle_2;
000056  f64b70ff          MOV      r0,#0xbfff
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;327        i2c.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
00005e  f44f4080          MOV      r0,#0x4000
000062  f8ad0010          STRH     r0,[sp,#0x10]
;;;328        i2c.I2C_ClockSpeed = 400000;
000066  481a              LDR      r0,|L7.208|
000068  9001              STR      r0,[sp,#4]
;;;329        I2C_Cmd(I2Cx, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4816              LDR      r0,|L7.200|
00006e  6800              LDR      r0,[r0,#0]  ; I2Cx
000070  f7fffffe          BL       I2C_Cmd
;;;330        I2C_Init(I2Cx, &i2c);
000074  a901              ADD      r1,sp,#4
000076  4814              LDR      r0,|L7.200|
000078  6800              LDR      r0,[r0,#0]  ; I2Cx
00007a  f7fffffe          BL       I2C_Init
;;;331    
;;;332        // I2C ER Interrupt
;;;333        nvic.NVIC_IRQChannel = i2cHardwareMap[index].er_irq;
00007e  eb040084          ADD      r0,r4,r4,LSL #2
000082  4910              LDR      r1,|L7.196|
000084  eb010080          ADD      r0,r1,r0,LSL #2
000088  7b40              LDRB     r0,[r0,#0xd]
00008a  f88d0014          STRB     r0,[sp,#0x14]
;;;334        nvic.NVIC_IRQChannelPreemptionPriority = 0;
00008e  2000              MOVS     r0,#0
000090  f88d0015          STRB     r0,[sp,#0x15]
;;;335        nvic.NVIC_IRQChannelSubPriority = 0;
000094  f88d0016          STRB     r0,[sp,#0x16]
;;;336        nvic.NVIC_IRQChannelCmd = ENABLE;
000098  2001              MOVS     r0,#1
00009a  f88d0017          STRB     r0,[sp,#0x17]
;;;337        NVIC_Init(&nvic);
00009e  a805              ADD      r0,sp,#0x14
0000a0  f7fffffe          BL       NVIC_Init
;;;338    
;;;339        // I2C EV Interrupt
;;;340        nvic.NVIC_IRQChannel = i2cHardwareMap[index].ev_irq;
0000a4  eb040084          ADD      r0,r4,r4,LSL #2
0000a8  4906              LDR      r1,|L7.196|
0000aa  eb010080          ADD      r0,r1,r0,LSL #2
0000ae  7b00              LDRB     r0,[r0,#0xc]
0000b0  f88d0014          STRB     r0,[sp,#0x14]
;;;341        nvic.NVIC_IRQChannelPreemptionPriority = 0;
0000b4  2000              MOVS     r0,#0
0000b6  f88d0015          STRB     r0,[sp,#0x15]
;;;342        NVIC_Init(&nvic);
0000ba  a805              ADD      r0,sp,#0x14
0000bc  f7fffffe          BL       NVIC_Init
;;;343    }
0000c0  b006              ADD      sp,sp,#0x18
0000c2  bd10              POP      {r4,pc}
;;;344    
                          ENDP

                  |L7.196|
                          DCD      i2cHardwareMap
                  |L7.200|
                          DCD      I2Cx
                  |L7.204|
                          DCD      I2Cx_index
                  |L7.208|
                          DCD      0x00061a80

                          AREA ||i.i2cRead||, CODE, READONLY, ALIGN=2

                  i2cRead PROC
;;;129    
;;;130    bool i2cRead(uint8_t addr_, uint8_t reg_, uint8_t len, uint8_t *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;131    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;132        uint32_t timeout = I2C_DEFAULT_TIMEOUT;
00000c  f2475430          MOV      r4,#0x7530
;;;133    
;;;134        addr = addr_ << 1;
000010  0670              LSLS     r0,r6,#25
000012  0e00              LSRS     r0,r0,#24
000014  4928              LDR      r1,|L8.184|
000016  7008              STRB     r0,[r1,#0]
;;;135        reg = reg_;
000018  4828              LDR      r0,|L8.188|
00001a  7007              STRB     r7,[r0,#0]
;;;136        writing = 0;
00001c  2000              MOVS     r0,#0
00001e  4928              LDR      r1,|L8.192|
000020  7008              STRB     r0,[r1,#0]
;;;137        reading = 1;
000022  2001              MOVS     r0,#1
000024  4927              LDR      r1,|L8.196|
000026  7008              STRB     r0,[r1,#0]
;;;138        read_p = buf;
000028  4827              LDR      r0,|L8.200|
00002a  6005              STR      r5,[r0,#0]  ; read_p
;;;139        write_p = buf;
00002c  4827              LDR      r0,|L8.204|
00002e  6005              STR      r5,[r0,#0]  ; write_p
;;;140        bytes = len;
000030  4827              LDR      r0,|L8.208|
000032  f8808000          STRB     r8,[r0,#0]
;;;141        busy = TRUE;
000036  2001              MOVS     r0,#1
000038  4926              LDR      r1,|L8.212|
00003a  7008              STRB     r0,[r1,#0]
;;;142        error = FALSE;
00003c  2000              MOVS     r0,#0
00003e  4926              LDR      r1,|L8.216|
000040  7008              STRB     r0,[r1,#0]
;;;143    
;;;144        if (!I2Cx)
000042  4826              LDR      r0,|L8.220|
000044  6800              LDR      r0,[r0,#0]  ; I2Cx
000046  b910              CBNZ     r0,|L8.78|
;;;145            return FALSE;
000048  2000              MOVS     r0,#0
                  |L8.74|
;;;146    
;;;147        if (!(I2Cx->CR2 & I2C_IT_EVT)) {                                    // if we are restarting the driver
;;;148            if (!(I2Cx->CR1 & 0x0100)) {                                    // ensure sending a start
;;;149                while (I2Cx->CR1 & 0x0200 && --timeout > 0) {
;;;150                    ;    // wait for any stop to finish sending
;;;151                }
;;;152                if (timeout == 0)
;;;153                    return i2cHandleHardwareFailure();
;;;154                I2C_GenerateSTART(I2Cx, ENABLE);                            // send the start for the new job
;;;155            }
;;;156            I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, ENABLE);            // allow the interrupts to fire off again
;;;157        }
;;;158    
;;;159        timeout = I2C_DEFAULT_TIMEOUT;
;;;160        while (busy && --timeout > 0) {
;;;161            ;
;;;162        }
;;;163        if (timeout == 0)
;;;164            return i2cHandleHardwareFailure();
;;;165    
;;;166        return TRUE;
;;;167    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.78|
00004e  4823              LDR      r0,|L8.220|
000050  6800              LDR      r0,[r0,#0]            ;147  ; I2Cx
000052  8880              LDRH     r0,[r0,#4]            ;147
000054  f4007000          AND      r0,r0,#0x200          ;147
000058  b9f8              CBNZ     r0,|L8.154|
00005a  4820              LDR      r0,|L8.220|
00005c  6800              LDR      r0,[r0,#0]            ;148  ; I2Cx
00005e  8800              LDRH     r0,[r0,#0]            ;148
000060  f4007080          AND      r0,r0,#0x100          ;148
000064  b990              CBNZ     r0,|L8.140|
000066  bf00              NOP                            ;149
                  |L8.104|
000068  481c              LDR      r0,|L8.220|
00006a  6800              LDR      r0,[r0,#0]            ;149  ; I2Cx
00006c  8800              LDRH     r0,[r0,#0]            ;149
00006e  f4007000          AND      r0,r0,#0x200          ;149
000072  b110              CBZ      r0,|L8.122|
000074  1e60              SUBS     r0,r4,#1              ;149
000076  0004              MOVS     r4,r0                 ;149
000078  d1f6              BNE      |L8.104|
                  |L8.122|
00007a  b914              CBNZ     r4,|L8.130|
00007c  f7fffffe          BL       i2cHandleHardwareFailure
000080  e7e3              B        |L8.74|
                  |L8.130|
000082  2101              MOVS     r1,#1                 ;154
000084  4815              LDR      r0,|L8.220|
000086  6800              LDR      r0,[r0,#0]            ;154  ; I2Cx
000088  f7fffffe          BL       I2C_GenerateSTART
                  |L8.140|
00008c  2201              MOVS     r2,#1                 ;156
00008e  f44f7140          MOV      r1,#0x300             ;156
000092  4812              LDR      r0,|L8.220|
000094  6800              LDR      r0,[r0,#0]            ;156  ; I2Cx
000096  f7fffffe          BL       I2C_ITConfig
                  |L8.154|
00009a  f2475430          MOV      r4,#0x7530            ;159
00009e  bf00              NOP                            ;160
                  |L8.160|
0000a0  480c              LDR      r0,|L8.212|
0000a2  7800              LDRB     r0,[r0,#0]            ;160  ; busy
0000a4  b110              CBZ      r0,|L8.172|
0000a6  1e60              SUBS     r0,r4,#1              ;160
0000a8  0004              MOVS     r4,r0                 ;160
0000aa  d1f9              BNE      |L8.160|
                  |L8.172|
0000ac  b914              CBNZ     r4,|L8.180|
0000ae  f7fffffe          BL       i2cHandleHardwareFailure
0000b2  e7ca              B        |L8.74|
                  |L8.180|
0000b4  2001              MOVS     r0,#1                 ;166
0000b6  e7c8              B        |L8.74|
;;;168    
                          ENDP

                  |L8.184|
                          DCD      addr
                  |L8.188|
                          DCD      ||reg||
                  |L8.192|
                          DCD      writing
                  |L8.196|
                          DCD      reading
                  |L8.200|
                          DCD      read_p
                  |L8.204|
                          DCD      write_p
                  |L8.208|
                          DCD      bytes
                  |L8.212|
                          DCD      busy
                  |L8.216|
                          DCD      error
                  |L8.220|
                          DCD      I2Cx

                          AREA ||i.i2cUnstick||, CODE, READONLY, ALIGN=2

                  i2cUnstick PROC
;;;349    
;;;350    static void i2cUnstick(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;351    {
;;;352        GPIO_TypeDef *gpio;
;;;353        GPIO_InitTypeDef GPIO_InitStructure;
;;;354        uint16_t scl, sda;
;;;355        int i;
;;;356        
;;;357    	  RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;358    	
;;;359        // prepare pins
;;;360        gpio = i2cHardwareMap[I2Cx_index].gpio;
00000a  4837              LDR      r0,|L9.232|
00000c  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00000e  eb000080          ADD      r0,r0,r0,LSL #2
000012  4936              LDR      r1,|L9.236|
000014  eb010080          ADD      r0,r1,r0,LSL #2
000018  6847              LDR      r7,[r0,#4]
;;;361        scl = i2cHardwareMap[I2Cx_index].scl;
00001a  4833              LDR      r0,|L9.232|
00001c  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00001e  eb000080          ADD      r0,r0,r0,LSL #2
000022  eb010080          ADD      r0,r1,r0,LSL #2
000026  8904              LDRH     r4,[r0,#8]
;;;362        sda = i2cHardwareMap[I2Cx_index].sda;
000028  482f              LDR      r0,|L9.232|
00002a  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
00002c  eb000080          ADD      r0,r0,r0,LSL #2
000030  eb010080          ADD      r0,r1,r0,LSL #2
000034  8945              LDRH     r5,[r0,#0xa]
;;;363        
;;;364        GPIO_SetBits(gpio, scl | sda);
000036  ea440105          ORR      r1,r4,r5
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       GPIO_SetBits
;;;365    
;;;366        GPIO_InitStructure.GPIO_Pin = scl | sda;
000040  ea440005          ORR      r0,r4,r5
000044  f8ad0000          STRH     r0,[sp,#0]
;;;367        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000048  2002              MOVS     r0,#2
00004a  f88d0002          STRB     r0,[sp,#2]
;;;368        GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_Out_OD;
00004e  2014              MOVS     r0,#0x14
000050  f88d0003          STRB     r0,[sp,#3]
;;;369        GPIO_Init(gpio, &GPIO_InitStructure);
000054  4669              MOV      r1,sp
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       GPIO_Init
;;;370    
;;;371        for (i = 0; i < 8; i++) {
00005c  2600              MOVS     r6,#0
00005e  e018              B        |L9.146|
                  |L9.96|
;;;372            // Wait for any clock stretching to finish
;;;373            while (!GPIO_ReadInputDataBit(gpio, scl))
000060  e002              B        |L9.104|
                  |L9.98|
;;;374                delay(10);
000062  200a              MOVS     r0,#0xa
000064  f7fffffe          BL       delay
                  |L9.104|
000068  4621              MOV      r1,r4                 ;373
00006a  4638              MOV      r0,r7                 ;373
00006c  f7fffffe          BL       GPIO_ReadInputDataBit
000070  2800              CMP      r0,#0                 ;373
000072  d0f6              BEQ      |L9.98|
;;;375    
;;;376            // Pull low
;;;377            GPIO_ResetBits(gpio, scl); // Set bus low
000074  4621              MOV      r1,r4
000076  4638              MOV      r0,r7
000078  f7fffffe          BL       GPIO_ResetBits
;;;378            delay(10);
00007c  200a              MOVS     r0,#0xa
00007e  f7fffffe          BL       delay
;;;379            // Release high again
;;;380            GPIO_SetBits(gpio, scl); // Set bus high
000082  4621              MOV      r1,r4
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       GPIO_SetBits
;;;381            delay(10);
00008a  200a              MOVS     r0,#0xa
00008c  f7fffffe          BL       delay
000090  1c76              ADDS     r6,r6,#1              ;371
                  |L9.146|
000092  2e08              CMP      r6,#8                 ;371
000094  dbe4              BLT      |L9.96|
;;;382        }
;;;383    
;;;384        // Generate a start then stop condition
;;;385        // SCL  PB10
;;;386        // SDA  PB11
;;;387        GPIO_ResetBits(gpio, sda); // Set bus data low
000096  4629              MOV      r1,r5
000098  4638              MOV      r0,r7
00009a  f7fffffe          BL       GPIO_ResetBits
;;;388        delay(10);
00009e  200a              MOVS     r0,#0xa
0000a0  f7fffffe          BL       delay
;;;389        GPIO_ResetBits(gpio, scl); // Set bus scl low
0000a4  4621              MOV      r1,r4
0000a6  4638              MOV      r0,r7
0000a8  f7fffffe          BL       GPIO_ResetBits
;;;390        delay(10);
0000ac  200a              MOVS     r0,#0xa
0000ae  f7fffffe          BL       delay
;;;391        GPIO_SetBits(gpio, scl); // Set bus scl high
0000b2  4621              MOV      r1,r4
0000b4  4638              MOV      r0,r7
0000b6  f7fffffe          BL       GPIO_SetBits
;;;392        delay(10);
0000ba  200a              MOVS     r0,#0xa
0000bc  f7fffffe          BL       delay
;;;393        GPIO_SetBits(gpio, sda); // Set bus sda high
0000c0  4629              MOV      r1,r5
0000c2  4638              MOV      r0,r7
0000c4  f7fffffe          BL       GPIO_SetBits
;;;394    
;;;395        // Init pins
;;;396        GPIO_InitStructure.GPIO_Pin = scl | sda;
0000c8  ea440005          ORR      r0,r4,r5
0000cc  f8ad0000          STRH     r0,[sp,#0]
;;;397        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
0000d0  2002              MOVS     r0,#2
0000d2  f88d0002          STRB     r0,[sp,#2]
;;;398        GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_AF_OD;
0000d6  201c              MOVS     r0,#0x1c
0000d8  f88d0003          STRB     r0,[sp,#3]
;;;399        GPIO_Init(gpio, &GPIO_InitStructure);
0000dc  4669              MOV      r1,sp
0000de  4638              MOV      r0,r7
0000e0  f7fffffe          BL       GPIO_Init
;;;400    }
0000e4  bdf8              POP      {r3-r7,pc}
;;;401    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L9.232|
                          DCD      I2Cx_index
                  |L9.236|
                          DCD      i2cHardwareMap

                          AREA ||i.i2cWrite||, CODE, READONLY, ALIGN=1

                  i2cWrite PROC
;;;124    
;;;125    bool i2cWrite(uint8_t addr_, uint8_t reg_, uint8_t data)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;126    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;127        return i2cWriteBuffer(addr_, reg_, 1, &data);
000006  ab02              ADD      r3,sp,#8
000008  2201              MOVS     r2,#1
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       i2cWriteBuffer
;;;128    }
000012  bd3e              POP      {r1-r5,pc}
;;;129    
                          ENDP


                          AREA ||i.i2cWriteBuffer||, CODE, READONLY, ALIGN=2

                  i2cWriteBuffer PROC
;;;85     
;;;86     bool i2cWriteBuffer(uint8_t addr_, uint8_t reg_, uint8_t len_, uint8_t *data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;87     {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
;;;88         uint32_t timeout = I2C_DEFAULT_TIMEOUT;
00000c  f2475430          MOV      r4,#0x7530
;;;89     
;;;90         addr = addr_ << 1;
000010  0670              LSLS     r0,r6,#25
000012  0e00              LSRS     r0,r0,#24
000014  4928              LDR      r1,|L11.184|
000016  7008              STRB     r0,[r1,#0]
;;;91         reg = reg_;
000018  4828              LDR      r0,|L11.188|
00001a  7007              STRB     r7,[r0,#0]
;;;92         writing = 1;
00001c  2001              MOVS     r0,#1
00001e  4928              LDR      r1,|L11.192|
000020  7008              STRB     r0,[r1,#0]
;;;93         reading = 0;
000022  2000              MOVS     r0,#0
000024  4927              LDR      r1,|L11.196|
000026  7008              STRB     r0,[r1,#0]
;;;94         write_p = data;
000028  4827              LDR      r0,|L11.200|
00002a  6005              STR      r5,[r0,#0]  ; write_p
;;;95         read_p = data;
00002c  4827              LDR      r0,|L11.204|
00002e  6005              STR      r5,[r0,#0]  ; read_p
;;;96         bytes = len_;
000030  4827              LDR      r0,|L11.208|
000032  f8808000          STRB     r8,[r0,#0]
;;;97         busy = TRUE;
000036  2001              MOVS     r0,#1
000038  4926              LDR      r1,|L11.212|
00003a  7008              STRB     r0,[r1,#0]
;;;98         error = FALSE;
00003c  2000              MOVS     r0,#0
00003e  4926              LDR      r1,|L11.216|
000040  7008              STRB     r0,[r1,#0]
;;;99     
;;;100        if (!I2Cx)
000042  4826              LDR      r0,|L11.220|
000044  6800              LDR      r0,[r0,#0]  ; I2Cx
000046  b910              CBNZ     r0,|L11.78|
;;;101            return FALSE;
000048  2000              MOVS     r0,#0
                  |L11.74|
;;;102    
;;;103        if (!(I2Cx->CR2 & I2C_IT_EVT)) {                                    // if we are restarting the driver
;;;104            if (!(I2Cx->CR1 & 0x0100)) {                                    // ensure sending a start
;;;105                while (I2Cx->CR1 & 0x0200 && --timeout > 0) {
;;;106                    ;    // wait for any stop to finish sending
;;;107                }
;;;108                if (timeout == 0)
;;;109                    return i2cHandleHardwareFailure();
;;;110                I2C_GenerateSTART(I2Cx, ENABLE);                            // send the start for the new job
;;;111            }
;;;112            I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, ENABLE);            // allow the interrupts to fire off again
;;;113        }
;;;114    
;;;115        timeout = I2C_DEFAULT_TIMEOUT;
;;;116        while (busy && --timeout > 0) {
;;;117            ;
;;;118        }
;;;119        if (timeout == 0)
;;;120            return i2cHandleHardwareFailure();
;;;121    
;;;122        return TRUE;
;;;123    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L11.78|
00004e  4823              LDR      r0,|L11.220|
000050  6800              LDR      r0,[r0,#0]            ;103  ; I2Cx
000052  8880              LDRH     r0,[r0,#4]            ;103
000054  f4007000          AND      r0,r0,#0x200          ;103
000058  b9f8              CBNZ     r0,|L11.154|
00005a  4820              LDR      r0,|L11.220|
00005c  6800              LDR      r0,[r0,#0]            ;104  ; I2Cx
00005e  8800              LDRH     r0,[r0,#0]            ;104
000060  f4007080          AND      r0,r0,#0x100          ;104
000064  b990              CBNZ     r0,|L11.140|
000066  bf00              NOP                            ;105
                  |L11.104|
000068  481c              LDR      r0,|L11.220|
00006a  6800              LDR      r0,[r0,#0]            ;105  ; I2Cx
00006c  8800              LDRH     r0,[r0,#0]            ;105
00006e  f4007000          AND      r0,r0,#0x200          ;105
000072  b110              CBZ      r0,|L11.122|
000074  1e60              SUBS     r0,r4,#1              ;105
000076  0004              MOVS     r4,r0                 ;105
000078  d1f6              BNE      |L11.104|
                  |L11.122|
00007a  b914              CBNZ     r4,|L11.130|
00007c  f7fffffe          BL       i2cHandleHardwareFailure
000080  e7e3              B        |L11.74|
                  |L11.130|
000082  2101              MOVS     r1,#1                 ;110
000084  4815              LDR      r0,|L11.220|
000086  6800              LDR      r0,[r0,#0]            ;110  ; I2Cx
000088  f7fffffe          BL       I2C_GenerateSTART
                  |L11.140|
00008c  2201              MOVS     r2,#1                 ;112
00008e  f44f7140          MOV      r1,#0x300             ;112
000092  4812              LDR      r0,|L11.220|
000094  6800              LDR      r0,[r0,#0]            ;112  ; I2Cx
000096  f7fffffe          BL       I2C_ITConfig
                  |L11.154|
00009a  f2475430          MOV      r4,#0x7530            ;115
00009e  bf00              NOP                            ;116
                  |L11.160|
0000a0  480c              LDR      r0,|L11.212|
0000a2  7800              LDRB     r0,[r0,#0]            ;116  ; busy
0000a4  b110              CBZ      r0,|L11.172|
0000a6  1e60              SUBS     r0,r4,#1              ;116
0000a8  0004              MOVS     r4,r0                 ;116
0000aa  d1f9              BNE      |L11.160|
                  |L11.172|
0000ac  b914              CBNZ     r4,|L11.180|
0000ae  f7fffffe          BL       i2cHandleHardwareFailure
0000b2  e7ca              B        |L11.74|
                  |L11.180|
0000b4  2001              MOVS     r0,#1                 ;122
0000b6  e7c8              B        |L11.74|
;;;124    
                          ENDP

                  |L11.184|
                          DCD      addr
                  |L11.188|
                          DCD      ||reg||
                  |L11.192|
                          DCD      writing
                  |L11.196|
                          DCD      reading
                  |L11.200|
                          DCD      write_p
                  |L11.204|
                          DCD      read_p
                  |L11.208|
                          DCD      bytes
                  |L11.212|
                          DCD      busy
                  |L11.216|
                          DCD      error
                  |L11.220|
                          DCD      I2Cx

                          AREA ||i.i2c_er_handler||, CODE, READONLY, ALIGN=2

                  i2c_er_handler PROC
;;;168    
;;;169    static void i2c_er_handler(void)
000000  b508              PUSH     {r3,lr}
;;;170    {
;;;171        // Read the I2C1 status register
;;;172        volatile uint32_t SR1Register = I2Cx->SR1;
000002  482e              LDR      r0,|L12.188|
000004  6800              LDR      r0,[r0,#0]  ; I2Cx
000006  8a80              LDRH     r0,[r0,#0x14]
000008  9000              STR      r0,[sp,#0]
;;;173    
;;;174        if (SR1Register & 0x0F00)                                           // an error
00000a  9800              LDR      r0,[sp,#0]
00000c  f4006070          AND      r0,r0,#0xf00
000010  b110              CBZ      r0,|L12.24|
;;;175            error = TRUE;
000012  2001              MOVS     r0,#1
000014  492a              LDR      r1,|L12.192|
000016  7008              STRB     r0,[r1,#0]
                  |L12.24|
;;;176    
;;;177        // If AF, BERR or ARLO, abandon the current job and commence new if there are jobs
;;;178        if (SR1Register & 0x0700) {
000018  9800              LDR      r0,[sp,#0]
00001a  f40060e0          AND      r0,r0,#0x700
00001e  2800              CMP      r0,#0
000020  d03f              BEQ      |L12.162|
;;;179            (void)I2Cx->SR2;                                                // read second status register to clear ADDR if it is set (note that BTF will not be set after a NACK)
000022  4826              LDR      r0,|L12.188|
000024  6800              LDR      r0,[r0,#0]  ; I2Cx
000026  8b00              LDRH     r0,[r0,#0x18]
;;;180            I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                        // disable the RXNE/TXE interrupt - prevent the ISR tailchaining onto the ER (hopefully)
000028  2200              MOVS     r2,#0
00002a  f44f6180          MOV      r1,#0x400
00002e  4823              LDR      r0,|L12.188|
000030  6800              LDR      r0,[r0,#0]  ; I2Cx
000032  f7fffffe          BL       I2C_ITConfig
;;;181            if (!(SR1Register & 0x0200) && !(I2Cx->CR1 & 0x0200)) {         // if we dont have an ARLO error, ensure sending of a stop
000036  9800              LDR      r0,[sp,#0]
000038  f4007000          AND      r0,r0,#0x200
00003c  bb20              CBNZ     r0,|L12.136|
00003e  481f              LDR      r0,|L12.188|
000040  6800              LDR      r0,[r0,#0]  ; I2Cx
000042  8800              LDRH     r0,[r0,#0]
000044  f4007000          AND      r0,r0,#0x200
000048  b9f0              CBNZ     r0,|L12.136|
;;;182                if (I2Cx->CR1 & 0x0100) {                                   // We are currently trying to send a start, this is very bad as start, stop will hang the peripheral
00004a  481c              LDR      r0,|L12.188|
00004c  6800              LDR      r0,[r0,#0]  ; I2Cx
00004e  8800              LDRH     r0,[r0,#0]
000050  f4007080          AND      r0,r0,#0x100
000054  b1c8              CBZ      r0,|L12.138|
;;;183                    while (I2Cx->CR1 & 0x0100) {
000056  bf00              NOP      
                  |L12.88|
000058  4818              LDR      r0,|L12.188|
00005a  6800              LDR      r0,[r0,#0]  ; I2Cx
00005c  8800              LDRH     r0,[r0,#0]
00005e  f4007080          AND      r0,r0,#0x100
000062  2800              CMP      r0,#0
000064  d1f8              BNE      |L12.88|
;;;184                        ;    // wait for any start to finish sending
;;;185                    }
;;;186                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // send stop to finalise bus transaction
000066  2101              MOVS     r1,#1
000068  4814              LDR      r0,|L12.188|
00006a  6800              LDR      r0,[r0,#0]  ; I2Cx
00006c  f7fffffe          BL       I2C_GenerateSTOP
;;;187                    while (I2Cx->CR1 & 0x0200) {
000070  bf00              NOP      
                  |L12.114|
000072  4812              LDR      r0,|L12.188|
000074  6800              LDR      r0,[r0,#0]  ; I2Cx
000076  8800              LDRH     r0,[r0,#0]
000078  f4007000          AND      r0,r0,#0x200
00007c  2800              CMP      r0,#0
00007e  d1f8              BNE      |L12.114|
;;;188                        ;    // wait for stop to finish sending
;;;189                    }
;;;190                    i2cInit(I2Cx_index);                                    // reset and configure the hardware
000080  4810              LDR      r0,|L12.196|
000082  7800              LDRB     r0,[r0,#0]  ; I2Cx_index
000084  f7fffffe          BL       i2cInit
                  |L12.136|
000088  e00b              B        |L12.162|
                  |L12.138|
;;;191                } else {
;;;192                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // stop to free up the bus
00008a  2101              MOVS     r1,#1
00008c  480b              LDR      r0,|L12.188|
00008e  6800              LDR      r0,[r0,#0]  ; I2Cx
000090  f7fffffe          BL       I2C_GenerateSTOP
;;;193                    I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);   // Disable EVT and ERR interrupts while bus inactive
000094  2200              MOVS     r2,#0
000096  f44f7140          MOV      r1,#0x300
00009a  4808              LDR      r0,|L12.188|
00009c  6800              LDR      r0,[r0,#0]  ; I2Cx
00009e  f7fffffe          BL       I2C_ITConfig
                  |L12.162|
;;;194                }
;;;195            }
;;;196        }
;;;197        I2Cx->SR1 &= ~0x0F00;                                               // reset all the error bits to clear the interrupt
0000a2  4806              LDR      r0,|L12.188|
0000a4  6800              LDR      r0,[r0,#0]  ; I2Cx
0000a6  8a80              LDRH     r0,[r0,#0x14]
0000a8  f4206070          BIC      r0,r0,#0xf00
0000ac  4903              LDR      r1,|L12.188|
0000ae  6809              LDR      r1,[r1,#0]  ; I2Cx
0000b0  8288              STRH     r0,[r1,#0x14]
;;;198        busy = FALSE;
0000b2  2000              MOVS     r0,#0
0000b4  4904              LDR      r1,|L12.200|
0000b6  7008              STRB     r0,[r1,#0]
;;;199    }
0000b8  bd08              POP      {r3,pc}
;;;200    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L12.188|
                          DCD      I2Cx
                  |L12.192|
                          DCD      error
                  |L12.196|
                          DCD      I2Cx_index
                  |L12.200|
                          DCD      busy

                          AREA ||i.i2c_ev_handler||, CODE, READONLY, ALIGN=2

                  i2c_ev_handler PROC
;;;200    
;;;201    void i2c_ev_handler(void)
000000  b510              PUSH     {r4,lr}
;;;202    {
;;;203        static uint8_t subaddress_sent, final_stop;                         // flag to indicate if subaddess sent, flag to indicate final bus condition
;;;204        static int8_t index;                                                // index is signed -1 == send the subaddress
;;;205        uint8_t SReg_1 = I2Cx->SR1;                                         // read the status register here
000002  48e8              LDR      r0,|L13.932|
000004  6800              LDR      r0,[r0,#0]  ; I2Cx
000006  8a80              LDRH     r0,[r0,#0x14]
000008  b2c4              UXTB     r4,r0
;;;206    
;;;207        if (SReg_1 & 0x0001) {                                              // we just sent a start - EV5 in ref manual
00000a  f0040001          AND      r0,r4,#1
00000e  2800              CMP      r0,#0
000010  d03f              BEQ      |L13.146|
;;;208            I2Cx->CR1 &= ~0x0800;                                           // reset the POS bit so ACK/NACK applied to the current byte
000012  48e4              LDR      r0,|L13.932|
000014  6800              LDR      r0,[r0,#0]  ; I2Cx
000016  8800              LDRH     r0,[r0,#0]
000018  f4206000          BIC      r0,r0,#0x800
00001c  49e1              LDR      r1,|L13.932|
00001e  6809              LDR      r1,[r1,#0]  ; I2Cx
000020  8008              STRH     r0,[r1,#0]
;;;209            I2C_AcknowledgeConfig(I2Cx, ENABLE);                            // make sure ACK is on
000022  2101              MOVS     r1,#1
000024  48df              LDR      r0,|L13.932|
000026  6800              LDR      r0,[r0,#0]  ; I2Cx
000028  f7fffffe          BL       I2C_AcknowledgeConfig
;;;210            index = 0;                                                      // reset the index
00002c  2000              MOVS     r0,#0
00002e  49de              LDR      r1,|L13.936|
000030  7008              STRB     r0,[r1,#0]
;;;211            if (reading && (subaddress_sent || 0xFF == reg)) {              // we have sent the subaddr
000032  48de              LDR      r0,|L13.940|
000034  7800              LDRB     r0,[r0,#0]  ; reading
000036  b1e8              CBZ      r0,|L13.116|
000038  48dd              LDR      r0,|L13.944|
00003a  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
00003c  b918              CBNZ     r0,|L13.70|
00003e  48dd              LDR      r0,|L13.948|
000040  7800              LDRB     r0,[r0,#0]  ; reg
000042  28ff              CMP      r0,#0xff
000044  d116              BNE      |L13.116|
                  |L13.70|
;;;212                subaddress_sent = 1;                                        // make sure this is set in case of no subaddress, so following code runs correctly
000046  2001              MOVS     r0,#1
000048  49d9              LDR      r1,|L13.944|
00004a  7008              STRB     r0,[r1,#0]
;;;213                if (bytes == 2)
00004c  48da              LDR      r0,|L13.952|
00004e  7800              LDRB     r0,[r0,#0]  ; bytes
000050  2802              CMP      r0,#2
000052  d107              BNE      |L13.100|
;;;214                    I2Cx->CR1 |= 0x0800;                                    // set the POS bit so NACK applied to the final byte in the two byte read
000054  48d3              LDR      r0,|L13.932|
000056  6800              LDR      r0,[r0,#0]  ; I2Cx
000058  8800              LDRH     r0,[r0,#0]
00005a  f4406000          ORR      r0,r0,#0x800
00005e  49d1              LDR      r1,|L13.932|
000060  6809              LDR      r1,[r1,#0]  ; I2Cx
000062  8008              STRH     r0,[r1,#0]
                  |L13.100|
;;;215                I2C_Send7bitAddress(I2Cx, addr, I2C_Direction_Receiver);    // send the address and set hardware mode
000064  2201              MOVS     r2,#1
000066  48d5              LDR      r0,|L13.956|
000068  7801              LDRB     r1,[r0,#0]  ; addr
00006a  48ce              LDR      r0,|L13.932|
00006c  6800              LDR      r0,[r0,#0]  ; I2Cx
00006e  f7fffffe          BL       I2C_Send7bitAddress
                  |L13.114|
000072  e17d              B        |L13.880|
                  |L13.116|
;;;216            } else {                                                        // direction is Tx, or we havent sent the sub and rep start
;;;217                I2C_Send7bitAddress(I2Cx, addr, I2C_Direction_Transmitter); // send the address and set hardware mode
000074  2200              MOVS     r2,#0
000076  48d1              LDR      r0,|L13.956|
000078  7801              LDRB     r1,[r0,#0]  ; addr
00007a  48ca              LDR      r0,|L13.932|
00007c  6800              LDR      r0,[r0,#0]  ; I2Cx
00007e  f7fffffe          BL       I2C_Send7bitAddress
;;;218                if (reg != 0xFF)                                            // 0xFF as subaddress means it will be ignored, in Tx or Rx mode
000082  48cc              LDR      r0,|L13.948|
000084  7800              LDRB     r0,[r0,#0]  ; reg
000086  28ff              CMP      r0,#0xff
000088  d0f3              BEQ      |L13.114|
;;;219                    index = -1;                                             // send a subaddress
00008a  20ff              MOVS     r0,#0xff
00008c  49c6              LDR      r1,|L13.936|
00008e  7008              STRB     r0,[r1,#0]
000090  e16e              B        |L13.880|
                  |L13.146|
;;;220            }
;;;221        } else if (SReg_1 & 0x0002) {                                       // we just sent the address - EV6 in ref manual
000092  f0040002          AND      r0,r4,#2
000096  2800              CMP      r0,#0
000098  d059              BEQ      |L13.334|
;;;222            // Read SR1,2 to clear ADDR
;;;223            __DMB();                                                        // memory fence to control hardware
00009a  f3bf8f50          DMB      #0x0
;;;224            if (bytes == 1 && reading && subaddress_sent) {                 // we are receiving 1 byte - EV6_3
00009e  48c6              LDR      r0,|L13.952|
0000a0  7800              LDRB     r0,[r0,#0]  ; bytes
0000a2  2801              CMP      r0,#1
0000a4  d11e              BNE      |L13.228|
0000a6  48c1              LDR      r0,|L13.940|
0000a8  7800              LDRB     r0,[r0,#0]  ; reading
0000aa  b1d8              CBZ      r0,|L13.228|
0000ac  48c0              LDR      r0,|L13.944|
0000ae  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
0000b0  b1c0              CBZ      r0,|L13.228|
;;;225                I2C_AcknowledgeConfig(I2Cx, DISABLE);                       // turn off ACK
0000b2  2100              MOVS     r1,#0
0000b4  48bb              LDR      r0,|L13.932|
0000b6  6800              LDR      r0,[r0,#0]  ; I2Cx
0000b8  f7fffffe          BL       I2C_AcknowledgeConfig
;;;226                __DMB();
0000bc  f3bf8f50          DMB      #0x0
;;;227                (void)I2Cx->SR2;                                            // clear ADDR after ACK is turned off
0000c0  48b8              LDR      r0,|L13.932|
0000c2  6800              LDR      r0,[r0,#0]  ; I2Cx
0000c4  8b00              LDRH     r0,[r0,#0x18]
;;;228                I2C_GenerateSTOP(I2Cx, ENABLE);                             // program the stop
0000c6  2101              MOVS     r1,#1
0000c8  48b6              LDR      r0,|L13.932|
0000ca  6800              LDR      r0,[r0,#0]  ; I2Cx
0000cc  f7fffffe          BL       I2C_GenerateSTOP
;;;229                final_stop = 1;
0000d0  2001              MOVS     r0,#1
0000d2  49bb              LDR      r1,|L13.960|
0000d4  7008              STRB     r0,[r1,#0]
;;;230                I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);                     // allow us to have an EV7
0000d6  2201              MOVS     r2,#1
0000d8  0281              LSLS     r1,r0,#10
0000da  48b2              LDR      r0,|L13.932|
0000dc  6800              LDR      r0,[r0,#0]  ; I2Cx
0000de  f7fffffe          BL       I2C_ITConfig
0000e2  e145              B        |L13.880|
                  |L13.228|
;;;231            } else {                                                        // EV6 and EV6_1
;;;232                (void)I2Cx->SR2;                                            // clear the ADDR here
0000e4  48af              LDR      r0,|L13.932|
0000e6  6800              LDR      r0,[r0,#0]  ; I2Cx
0000e8  8b00              LDRH     r0,[r0,#0x18]
;;;233                __DMB();
0000ea  f3bf8f50          DMB      #0x0
;;;234                if (bytes == 2 && reading && subaddress_sent) {             // rx 2 bytes - EV6_1
0000ee  48b2              LDR      r0,|L13.952|
0000f0  7800              LDRB     r0,[r0,#0]  ; bytes
0000f2  2802              CMP      r0,#2
0000f4  d112              BNE      |L13.284|
0000f6  48ad              LDR      r0,|L13.940|
0000f8  7800              LDRB     r0,[r0,#0]  ; reading
0000fa  b178              CBZ      r0,|L13.284|
0000fc  48ac              LDR      r0,|L13.944|
0000fe  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
000100  b160              CBZ      r0,|L13.284|
;;;235                    I2C_AcknowledgeConfig(I2Cx, DISABLE);                   // turn off ACK
000102  2100              MOVS     r1,#0
000104  48a7              LDR      r0,|L13.932|
000106  6800              LDR      r0,[r0,#0]  ; I2Cx
000108  f7fffffe          BL       I2C_AcknowledgeConfig
;;;236                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to fill
00010c  2200              MOVS     r2,#0
00010e  f44f6180          MOV      r1,#0x400
000112  48a4              LDR      r0,|L13.932|
000114  6800              LDR      r0,[r0,#0]  ; I2Cx
000116  f7fffffe          BL       I2C_ITConfig
00011a  e129              B        |L13.880|
                  |L13.284|
;;;237                } else if (bytes == 3 && reading && subaddress_sent)        // rx 3 bytes
00011c  48a6              LDR      r0,|L13.952|
00011e  7800              LDRB     r0,[r0,#0]  ; bytes
000120  2803              CMP      r0,#3
000122  d10d              BNE      |L13.320|
000124  48a1              LDR      r0,|L13.940|
000126  7800              LDRB     r0,[r0,#0]  ; reading
000128  b150              CBZ      r0,|L13.320|
00012a  48a1              LDR      r0,|L13.944|
00012c  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
00012e  b138              CBZ      r0,|L13.320|
;;;238                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // make sure RXNE disabled so we get a BTF in two bytes time
000130  2200              MOVS     r2,#0
000132  f44f6180          MOV      r1,#0x400
000136  489b              LDR      r0,|L13.932|
000138  6800              LDR      r0,[r0,#0]  ; I2Cx
00013a  f7fffffe          BL       I2C_ITConfig
00013e  e117              B        |L13.880|
                  |L13.320|
;;;239                else                                                        // receiving greater than three bytes, sending subaddress, or transmitting
;;;240                    I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);
000140  2201              MOVS     r2,#1
000142  0291              LSLS     r1,r2,#10
000144  4897              LDR      r0,|L13.932|
000146  6800              LDR      r0,[r0,#0]  ; I2Cx
000148  f7fffffe          BL       I2C_ITConfig
00014c  e110              B        |L13.880|
                  |L13.334|
;;;241            }
;;;242        } else if (SReg_1 & 0x004) {                                        // Byte transfer finished - EV7_2, EV7_3 or EV8_2
00014e  f0040004          AND      r0,r4,#4
000152  2800              CMP      r0,#0
000154  d072              BEQ      |L13.572|
;;;243            final_stop = 1;
000156  2001              MOVS     r0,#1
000158  4999              LDR      r1,|L13.960|
00015a  7008              STRB     r0,[r1,#0]
;;;244            if (reading && subaddress_sent) {                               // EV7_2, EV7_3
00015c  4893              LDR      r0,|L13.940|
00015e  7800              LDRB     r0,[r0,#0]  ; reading
000160  2800              CMP      r0,#0
000162  d06d              BEQ      |L13.576|
000164  4892              LDR      r0,|L13.944|
000166  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
000168  2800              CMP      r0,#0
00016a  d069              BEQ      |L13.576|
;;;245                if (bytes > 2) {                                            // EV7_2
00016c  4892              LDR      r0,|L13.952|
00016e  7800              LDRB     r0,[r0,#0]  ; bytes
000170  2802              CMP      r0,#2
000172  dd31              BLE      |L13.472|
;;;246                    I2C_AcknowledgeConfig(I2Cx, DISABLE);                   // turn off ACK
000174  2100              MOVS     r1,#0
000176  488b              LDR      r0,|L13.932|
000178  6800              LDR      r0,[r0,#0]  ; I2Cx
00017a  f7fffffe          BL       I2C_AcknowledgeConfig
;;;247                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N-2
00017e  4889              LDR      r0,|L13.932|
000180  6800              LDR      r0,[r0,#0]  ; I2Cx
000182  8a00              LDRH     r0,[r0,#0x10]
000184  b2c1              UXTB     r1,r0
000186  4888              LDR      r0,|L13.936|
000188  f9902000          LDRSB    r2,[r0,#0]  ; index
00018c  7800              LDRB     r0,[r0,#0]  ; index
00018e  1c40              ADDS     r0,r0,#1
000190  b240              SXTB     r0,r0
000192  4b85              LDR      r3,|L13.936|
000194  7018              STRB     r0,[r3,#0]
000196  488b              LDR      r0,|L13.964|
000198  6800              LDR      r0,[r0,#0]  ; read_p
00019a  5481              STRB     r1,[r0,r2]
;;;248                    I2C_GenerateSTOP(I2Cx, ENABLE);                         // program the Stop
00019c  2101              MOVS     r1,#1
00019e  4881              LDR      r0,|L13.932|
0001a0  6800              LDR      r0,[r0,#0]  ; I2Cx
0001a2  f7fffffe          BL       I2C_GenerateSTOP
;;;249                    final_stop = 1;                                         // required to fix hardware
0001a6  2001              MOVS     r0,#1
0001a8  4985              LDR      r1,|L13.960|
0001aa  7008              STRB     r0,[r1,#0]
;;;250                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N - 1
0001ac  487d              LDR      r0,|L13.932|
0001ae  6800              LDR      r0,[r0,#0]  ; I2Cx
0001b0  8a00              LDRH     r0,[r0,#0x10]
0001b2  b2c1              UXTB     r1,r0
0001b4  487c              LDR      r0,|L13.936|
0001b6  f9902000          LDRSB    r2,[r0,#0]  ; index
0001ba  7800              LDRB     r0,[r0,#0]  ; index
0001bc  1c40              ADDS     r0,r0,#1
0001be  b240              SXTB     r0,r0
0001c0  4b79              LDR      r3,|L13.936|
0001c2  7018              STRB     r0,[r3,#0]
0001c4  487f              LDR      r0,|L13.964|
0001c6  6800              LDR      r0,[r0,#0]  ; read_p
0001c8  5481              STRB     r1,[r0,r2]
;;;251                    I2C_ITConfig(I2Cx, I2C_IT_BUF, ENABLE);                 // enable TXE to allow the final EV7
0001ca  2201              MOVS     r2,#1
0001cc  0291              LSLS     r1,r2,#10
0001ce  4875              LDR      r0,|L13.932|
0001d0  6800              LDR      r0,[r0,#0]  ; I2Cx
0001d2  f7fffffe          BL       I2C_ITConfig
0001d6  e056              B        |L13.646|
                  |L13.472|
;;;252                } else {                                                    // EV7_3
;;;253                    if (final_stop)
0001d8  4879              LDR      r0,|L13.960|
0001da  7800              LDRB     r0,[r0,#0]  ; final_stop
0001dc  b128              CBZ      r0,|L13.490|
;;;254                        I2C_GenerateSTOP(I2Cx, ENABLE);                     // program the Stop
0001de  2101              MOVS     r1,#1
0001e0  4870              LDR      r0,|L13.932|
0001e2  6800              LDR      r0,[r0,#0]  ; I2Cx
0001e4  f7fffffe          BL       I2C_GenerateSTOP
0001e8  e004              B        |L13.500|
                  |L13.490|
;;;255                    else
;;;256                        I2C_GenerateSTART(I2Cx, ENABLE);                    // program a rep start
0001ea  2101              MOVS     r1,#1
0001ec  486d              LDR      r0,|L13.932|
0001ee  6800              LDR      r0,[r0,#0]  ; I2Cx
0001f0  f7fffffe          BL       I2C_GenerateSTART
                  |L13.500|
;;;257                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N - 1
0001f4  486b              LDR      r0,|L13.932|
0001f6  6800              LDR      r0,[r0,#0]  ; I2Cx
0001f8  8a00              LDRH     r0,[r0,#0x10]
0001fa  b2c1              UXTB     r1,r0
0001fc  486a              LDR      r0,|L13.936|
0001fe  f9902000          LDRSB    r2,[r0,#0]  ; index
000202  7800              LDRB     r0,[r0,#0]  ; index
000204  1c40              ADDS     r0,r0,#1
000206  b240              SXTB     r0,r0
000208  4b67              LDR      r3,|L13.936|
00020a  7018              STRB     r0,[r3,#0]
00020c  486d              LDR      r0,|L13.964|
00020e  6800              LDR      r0,[r0,#0]  ; read_p
000210  5481              STRB     r1,[r0,r2]
;;;258                    read_p[index++] = (uint8_t)I2Cx->DR;                    // read data N
000212  4864              LDR      r0,|L13.932|
000214  6800              LDR      r0,[r0,#0]  ; I2Cx
000216  8a00              LDRH     r0,[r0,#0x10]
000218  b2c1              UXTB     r1,r0
00021a  4618              MOV      r0,r3
00021c  f9902000          LDRSB    r2,[r0,#0]  ; index
000220  7800              LDRB     r0,[r0,#0]  ; index
000222  1c40              ADDS     r0,r0,#1
000224  b240              SXTB     r0,r0
000226  7018              STRB     r0,[r3,#0]
000228  4866              LDR      r0,|L13.964|
00022a  6800              LDR      r0,[r0,#0]  ; read_p
00022c  5481              STRB     r1,[r0,r2]
;;;259                    index++;                                                // to show job completed
00022e  4618              MOV      r0,r3
000230  7800              LDRB     r0,[r0,#0]  ; index
000232  1c40              ADDS     r0,r0,#1
000234  b240              SXTB     r0,r0
000236  4619              MOV      r1,r3
000238  7008              STRB     r0,[r1,#0]
00023a  e024              B        |L13.646|
                  |L13.572|
00023c  e02c              B        |L13.664|
00023e  e7ff              B        |L13.576|
                  |L13.576|
;;;260                }
;;;261            } else {                                                        // EV8_2, which may be due to a subaddress sent or a write completion
;;;262                if (subaddress_sent || (writing)) {
000240  485b              LDR      r0,|L13.944|
000242  7800              LDRB     r0,[r0,#0]  ; subaddress_sent
000244  b910              CBNZ     r0,|L13.588|
000246  4860              LDR      r0,|L13.968|
000248  7800              LDRB     r0,[r0,#0]  ; writing
00024a  b1a0              CBZ      r0,|L13.630|
                  |L13.588|
;;;263                    if (final_stop)
00024c  485c              LDR      r0,|L13.960|
00024e  7800              LDRB     r0,[r0,#0]  ; final_stop
000250  b128              CBZ      r0,|L13.606|
;;;264                        I2C_GenerateSTOP(I2Cx, ENABLE);                     // program the Stop
000252  2101              MOVS     r1,#1
000254  4853              LDR      r0,|L13.932|
000256  6800              LDR      r0,[r0,#0]  ; I2Cx
000258  f7fffffe          BL       I2C_GenerateSTOP
00025c  e004              B        |L13.616|
                  |L13.606|
;;;265                    else
;;;266                        I2C_GenerateSTART(I2Cx, ENABLE);                    // program a rep start
00025e  2101              MOVS     r1,#1
000260  4850              LDR      r0,|L13.932|
000262  6800              LDR      r0,[r0,#0]  ; I2Cx
000264  f7fffffe          BL       I2C_GenerateSTART
                  |L13.616|
;;;267                    index++;                                                // to show that the job is complete
000268  484f              LDR      r0,|L13.936|
00026a  7800              LDRB     r0,[r0,#0]  ; index
00026c  1c40              ADDS     r0,r0,#1
00026e  b240              SXTB     r0,r0
000270  494d              LDR      r1,|L13.936|
000272  7008              STRB     r0,[r1,#0]
000274  e007              B        |L13.646|
                  |L13.630|
;;;268                } else {                                                    // We need to send a subaddress
;;;269                    I2C_GenerateSTART(I2Cx, ENABLE);                        // program the repeated Start
000276  2101              MOVS     r1,#1
000278  484a              LDR      r0,|L13.932|
00027a  6800              LDR      r0,[r0,#0]  ; I2Cx
00027c  f7fffffe          BL       I2C_GenerateSTART
;;;270                    subaddress_sent = 1;                                    // this is set back to zero upon completion of the current task
000280  2001              MOVS     r0,#1
000282  494b              LDR      r1,|L13.944|
000284  7008              STRB     r0,[r1,#0]
                  |L13.646|
;;;271                }
;;;272            }
;;;273            // we must wait for the start to clear, otherwise we get constant BTF
;;;274            while (I2Cx->CR1 & 0x0100) {
000286  bf00              NOP      
                  |L13.648|
000288  4846              LDR      r0,|L13.932|
00028a  6800              LDR      r0,[r0,#0]  ; I2Cx
00028c  8800              LDRH     r0,[r0,#0]
00028e  f4007080          AND      r0,r0,#0x100
000292  2800              CMP      r0,#0
000294  d1f8              BNE      |L13.648|
000296  e06b              B        |L13.880|
                  |L13.664|
;;;275                ;
;;;276            }
;;;277        } else if (SReg_1 & 0x0040) {                                       // Byte received - EV7
000298  f0040040          AND      r0,r4,#0x40
00029c  b358              CBZ      r0,|L13.758|
;;;278            read_p[index++] = (uint8_t)I2Cx->DR;
00029e  4841              LDR      r0,|L13.932|
0002a0  6800              LDR      r0,[r0,#0]  ; I2Cx
0002a2  8a00              LDRH     r0,[r0,#0x10]
0002a4  b2c1              UXTB     r1,r0
0002a6  4840              LDR      r0,|L13.936|
0002a8  f9902000          LDRSB    r2,[r0,#0]  ; index
0002ac  7800              LDRB     r0,[r0,#0]  ; index
0002ae  1c40              ADDS     r0,r0,#1
0002b0  b240              SXTB     r0,r0
0002b2  4b3d              LDR      r3,|L13.936|
0002b4  7018              STRB     r0,[r3,#0]
0002b6  4843              LDR      r0,|L13.964|
0002b8  6800              LDR      r0,[r0,#0]  ; read_p
0002ba  5481              STRB     r1,[r0,r2]
;;;279            if (bytes == (index + 3))
0002bc  483e              LDR      r0,|L13.952|
0002be  7801              LDRB     r1,[r0,#0]  ; bytes
0002c0  4618              MOV      r0,r3
0002c2  f9900000          LDRSB    r0,[r0,#0]  ; index
0002c6  1cc0              ADDS     r0,r0,#3
0002c8  4281              CMP      r1,r0
0002ca  d106              BNE      |L13.730|
;;;280                I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                    // disable TXE to allow the buffer to flush so we can get an EV7_2
0002cc  2200              MOVS     r2,#0
0002ce  f44f6180          MOV      r1,#0x400
0002d2  4834              LDR      r0,|L13.932|
0002d4  6800              LDR      r0,[r0,#0]  ; I2Cx
0002d6  f7fffffe          BL       I2C_ITConfig
                  |L13.730|
;;;281            if (bytes == index)                                             // We have completed a final EV7
0002da  4837              LDR      r0,|L13.952|
0002dc  7800              LDRB     r0,[r0,#0]  ; bytes
0002de  4932              LDR      r1,|L13.936|
0002e0  f9911000          LDRSB    r1,[r1,#0]  ; index
0002e4  4288              CMP      r0,r1
0002e6  d143              BNE      |L13.880|
;;;282                index++;                                                    // to show job is complete
0002e8  482f              LDR      r0,|L13.936|
0002ea  7800              LDRB     r0,[r0,#0]  ; index
0002ec  1c40              ADDS     r0,r0,#1
0002ee  b240              SXTB     r0,r0
0002f0  492d              LDR      r1,|L13.936|
0002f2  7008              STRB     r0,[r1,#0]
0002f4  e03c              B        |L13.880|
                  |L13.758|
;;;283        } else if (SReg_1 & 0x0080) {                                       // Byte transmitted EV8 / EV8_1
0002f6  f0040080          AND      r0,r4,#0x80
0002fa  b300              CBZ      r0,|L13.830|
;;;284            if (index != -1) {                                              // we dont have a subaddress to send
0002fc  482a              LDR      r0,|L13.936|
0002fe  f9900000          LDRSB    r0,[r0,#0]  ; index
000302  1c40              ADDS     r0,r0,#1
000304  b1e0              CBZ      r0,|L13.832|
;;;285                I2Cx->DR = write_p[index++];
000306  4828              LDR      r0,|L13.936|
000308  f9901000          LDRSB    r1,[r0,#0]  ; index
00030c  7800              LDRB     r0,[r0,#0]  ; index
00030e  1c40              ADDS     r0,r0,#1
000310  b240              SXTB     r0,r0
000312  4a25              LDR      r2,|L13.936|
000314  7010              STRB     r0,[r2,#0]
000316  482d              LDR      r0,|L13.972|
000318  6800              LDR      r0,[r0,#0]  ; write_p
00031a  5c40              LDRB     r0,[r0,r1]
00031c  4921              LDR      r1,|L13.932|
00031e  6809              LDR      r1,[r1,#0]  ; I2Cx
000320  8208              STRH     r0,[r1,#0x10]
;;;286                if (bytes == index)                                         // we have sent all the data
000322  4825              LDR      r0,|L13.952|
000324  7800              LDRB     r0,[r0,#0]  ; bytes
000326  4611              MOV      r1,r2
000328  f9911000          LDRSB    r1,[r1,#0]  ; index
00032c  4288              CMP      r0,r1
00032e  d11f              BNE      |L13.880|
;;;287                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to flush
000330  2200              MOVS     r2,#0
000332  f44f6180          MOV      r1,#0x400
000336  481b              LDR      r0,|L13.932|
000338  6800              LDR      r0,[r0,#0]  ; I2Cx
00033a  f7fffffe          BL       I2C_ITConfig
                  |L13.830|
00033e  e017              B        |L13.880|
                  |L13.832|
;;;288            } else {
;;;289                index++;
000340  4819              LDR      r0,|L13.936|
000342  7800              LDRB     r0,[r0,#0]  ; index
000344  1c40              ADDS     r0,r0,#1
000346  b240              SXTB     r0,r0
000348  4917              LDR      r1,|L13.936|
00034a  7008              STRB     r0,[r1,#0]
;;;290                I2Cx->DR = reg;                                             // send the subaddress
00034c  4819              LDR      r0,|L13.948|
00034e  7800              LDRB     r0,[r0,#0]  ; reg
000350  4914              LDR      r1,|L13.932|
000352  6809              LDR      r1,[r1,#0]  ; I2Cx
000354  8208              STRH     r0,[r1,#0x10]
;;;291                if (reading || !bytes)                                      // if receiving or sending 0 bytes, flush now
000356  4815              LDR      r0,|L13.940|
000358  7800              LDRB     r0,[r0,#0]  ; reading
00035a  b910              CBNZ     r0,|L13.866|
00035c  4816              LDR      r0,|L13.952|
00035e  7800              LDRB     r0,[r0,#0]  ; bytes
000360  b930              CBNZ     r0,|L13.880|
                  |L13.866|
;;;292                    I2C_ITConfig(I2Cx, I2C_IT_BUF, DISABLE);                // disable TXE to allow the buffer to flush
000362  2200              MOVS     r2,#0
000364  f44f6180          MOV      r1,#0x400
000368  480e              LDR      r0,|L13.932|
00036a  6800              LDR      r0,[r0,#0]  ; I2Cx
00036c  f7fffffe          BL       I2C_ITConfig
                  |L13.880|
;;;293            }
;;;294        }
;;;295        if (index == bytes + 1) {                                           // we have completed the current job
000370  480d              LDR      r0,|L13.936|
000372  f9901000          LDRSB    r1,[r0,#0]  ; index
000376  4810              LDR      r0,|L13.952|
000378  7800              LDRB     r0,[r0,#0]  ; bytes
00037a  1c40              ADDS     r0,r0,#1
00037c  4281              CMP      r1,r0
00037e  d10f              BNE      |L13.928|
;;;296            subaddress_sent = 0;                                            // reset this here
000380  2000              MOVS     r0,#0
000382  490b              LDR      r1,|L13.944|
000384  7008              STRB     r0,[r1,#0]
;;;297            if (final_stop)                                                 // If there is a final stop and no more jobs, bus is inactive, disable interrupts to prevent BTF
000386  480e              LDR      r0,|L13.960|
000388  7800              LDRB     r0,[r0,#0]  ; final_stop
00038a  b130              CBZ      r0,|L13.922|
;;;298                I2C_ITConfig(I2Cx, I2C_IT_EVT | I2C_IT_ERR, DISABLE);       // Disable EVT and ERR interrupts while bus inactive
00038c  2200              MOVS     r2,#0
00038e  f44f7140          MOV      r1,#0x300
000392  4804              LDR      r0,|L13.932|
000394  6800              LDR      r0,[r0,#0]  ; I2Cx
000396  f7fffffe          BL       I2C_ITConfig
                  |L13.922|
;;;299            busy = FALSE;
00039a  2000              MOVS     r0,#0
00039c  490c              LDR      r1,|L13.976|
00039e  7008              STRB     r0,[r1,#0]
                  |L13.928|
;;;300        }
;;;301    }
0003a0  bd10              POP      {r4,pc}
;;;302    
                          ENDP

0003a2  0000              DCW      0x0000
                  |L13.932|
                          DCD      I2Cx
                  |L13.936|
                          DCD      index
                  |L13.940|
                          DCD      reading
                  |L13.944|
                          DCD      subaddress_sent
                  |L13.948|
                          DCD      ||reg||
                  |L13.952|
                          DCD      bytes
                  |L13.956|
                          DCD      addr
                  |L13.960|
                          DCD      final_stop
                  |L13.964|
                          DCD      read_p
                  |L13.968|
                          DCD      writing
                  |L13.972|
                          DCD      write_p
                  |L13.976|
                          DCD      busy

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  i2cHardwareMap
                          DCD      0x40005400
                          DCD      0x40010c00
000008  00400080          DCW      0x0040,0x0080
00000c  1f200000          DCB      0x1f,0x20,0x00,0x00
                          DCD      0x00200000
                          DCD      0x40005800
                          DCD      0x40010c00
00001c  04000800          DCW      0x0400,0x0800
000020  21220000          DCB      0x21,0x22,0x00,0x00
                          DCD      0x00400000

                          AREA ||.data||, DATA, ALIGN=2

                  I2Cx
                          DCD      0x00000000
                  I2Cx_index
000004  0000              DCB      0x00,0x00
                  i2cErrorCount
000006  0000              DCW      0x0000
                  error
000008  00                DCB      0x00
                  busy
000009  00                DCB      0x00
                  addr
00000a  00                DCB      0x00
                  ||reg||
00000b  00                DCB      0x00
                  bytes
00000c  00                DCB      0x00
                  writing
00000d  00                DCB      0x00
                  reading
00000e  0000              DCB      0x00,0x00
                  write_p
                          DCD      0x00000000
                  read_p
                          DCD      0x00000000
                  subaddress_sent
000018  00                DCB      0x00
                  final_stop
000019  00                DCB      0x00
                  index
00001a  00                DCB      0x00
