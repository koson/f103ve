; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\i2c.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Driver\STMFLASH -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Driver\Modules_hmc5883 -I..\..\User\Driver\Modules_mpu6050 -I..\..\User\Driver\Modules_ms5611 -I..\..\User\Driver\Modules_oled -I..\..\User\Driver\Modules_ultrasonic -I..\..\User\Function\Heigh -I"C:\Users\Administrator\Desktop\机器人课飞控\机器人课无人机原始程序 - 副本\Project\MDK-ARM(uV5)\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\i2c.crf ..\..\User\Driver\IIC\I2C.c]
                          THUMB

                          AREA ||i.I2C_Ack||, CODE, READONLY, ALIGN=2

                  I2C_Ack PROC
;;;92     ****************************************************************************** */
;;;93     void I2C_Ack(void)
000000  b500              PUSH     {lr}
;;;94     {	
;;;95     	SCL_L;
000002  f44f6080          MOV      r0,#0x400
000006  490c              LDR      r1,|L1.56|
000008  6008              STR      r0,[r1,#0]
;;;96     	I2C_delay();
00000a  f7fffffe          BL       I2C_delay
;;;97     	SDA_L;
00000e  f44f6000          MOV      r0,#0x800
000012  4909              LDR      r1,|L1.56|
000014  6008              STR      r0,[r1,#0]
;;;98     	I2C_delay();
000016  f7fffffe          BL       I2C_delay
;;;99     	SCL_H;
00001a  f44f6080          MOV      r0,#0x400
00001e  4906              LDR      r1,|L1.56|
000020  1f09              SUBS     r1,r1,#4
000022  6008              STR      r0,[r1,#0]
;;;100    	I2C_delay();
000024  f7fffffe          BL       I2C_delay
;;;101    	SCL_L;
000028  f44f6080          MOV      r0,#0x400
00002c  4902              LDR      r1,|L1.56|
00002e  6008              STR      r0,[r1,#0]
;;;102    	I2C_delay();
000030  f7fffffe          BL       I2C_delay
;;;103    }   
000034  bd00              POP      {pc}
;;;104    /*******************************************************************************
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x40010c14

                          AREA ||i.I2C_INIT||, CODE, READONLY, ALIGN=2

                  I2C_INIT PROC
;;;10     ****************************************************************************** */
;;;11     void I2C_INIT(void)
000000  b508              PUSH     {r3,lr}
;;;12     {
;;;13       GPIO_InitTypeDef  GPIO_InitStructure; 
;;;14      
;;;15     	RCC_APB2PeriphClockCmd(RCC_GPIO_I2C, ENABLE);  //使能GPIOB时钟
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;16       
;;;17     	GPIO_InitStructure.GPIO_Pin =  SCL_PIN;
00000a  f44f6080          MOV      r0,#0x400
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;18       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;19       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  
000018  2014              MOVS     r0,#0x14
00001a  f88d0003          STRB     r0,[sp,#3]
;;;20       GPIO_Init(GPIO_I2C, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  480a              LDR      r0,|L2.76|
000022  f7fffffe          BL       GPIO_Init
;;;21     
;;;22       GPIO_InitStructure.GPIO_Pin =  SDA_PIN;
000026  f44f6000          MOV      r0,#0x800
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;23       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002e  2003              MOVS     r0,#3
000030  f88d0002          STRB     r0,[sp,#2]
;;;24       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000034  2014              MOVS     r0,#0x14
000036  f88d0003          STRB     r0,[sp,#3]
;;;25       GPIO_Init(GPIO_I2C, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4803              LDR      r0,|L2.76|
00003e  f7fffffe          BL       GPIO_Init
;;;26     	delay(0XFFF);
000042  f64070ff          MOV      r0,#0xfff
000046  f7fffffe          BL       delay
;;;27     }
00004a  bd08              POP      {r3,pc}
;;;28     /*******************************************************************************
                          ENDP

                  |L2.76|
                          DCD      0x40010c00

                          AREA ||i.I2C_NoAck||, CODE, READONLY, ALIGN=2

                  I2C_NoAck PROC
;;;110    ****************************************************************************** */
;;;111    void I2C_NoAck(void)
000000  b500              PUSH     {lr}
;;;112    {	
;;;113    	SCL_L;
000002  f44f6080          MOV      r0,#0x400
000006  490c              LDR      r1,|L3.56|
000008  6008              STR      r0,[r1,#0]
;;;114    	I2C_delay();
00000a  f7fffffe          BL       I2C_delay
;;;115    	SDA_H;
00000e  f44f6000          MOV      r0,#0x800
000012  4909              LDR      r1,|L3.56|
000014  1f09              SUBS     r1,r1,#4
000016  6008              STR      r0,[r1,#0]
;;;116    	I2C_delay();
000018  f7fffffe          BL       I2C_delay
;;;117    	SCL_H;
00001c  f44f6080          MOV      r0,#0x400
000020  4905              LDR      r1,|L3.56|
000022  1f09              SUBS     r1,r1,#4
000024  6008              STR      r0,[r1,#0]
;;;118    	I2C_delay();
000026  f7fffffe          BL       I2C_delay
;;;119    	SCL_L;
00002a  f44f6080          MOV      r0,#0x400
00002e  4902              LDR      r1,|L3.56|
000030  6008              STR      r0,[r1,#0]
;;;120    	I2C_delay();
000032  f7fffffe          BL       I2C_delay
;;;121    } 
000036  bd00              POP      {pc}
;;;122    /*******************************************************************************
                          ENDP

                  |L3.56|
                          DCD      0x40010c14

                          AREA ||i.I2C_RadeByte||, CODE, READONLY, ALIGN=2

                  I2C_RadeByte PROC
;;;178    ****************************************************************************** */
;;;179    unsigned char I2C_RadeByte(void)  //数据从高位到低位//
000000  b500              PUSH     {lr}
;;;180    { 
;;;181        u8 i=8;
000002  2108              MOVS     r1,#8
;;;182        u8 ReceiveByte=0;
000004  2000              MOVS     r0,#0
;;;183    
;;;184        SDA_H;				
000006  020a              LSLS     r2,r1,#8
000008  4b12              LDR      r3,|L4.84|
00000a  601a              STR      r2,[r3,#0]
;;;185        while(i--)
00000c  e016              B        |L4.60|
                  |L4.14|
;;;186        {
;;;187          ReceiveByte<<=1;      
00000e  0642              LSLS     r2,r0,#25
000010  0e10              LSRS     r0,r2,#24
;;;188          SCL_L;
000012  f44f6280          MOV      r2,#0x400
000016  4b0f              LDR      r3,|L4.84|
000018  1d1b              ADDS     r3,r3,#4
00001a  601a              STR      r2,[r3,#0]
;;;189          I2C_delay();
00001c  f7fffffe          BL       I2C_delay
;;;190    	  SCL_H;
000020  f44f6280          MOV      r2,#0x400
000024  4b0b              LDR      r3,|L4.84|
000026  601a              STR      r2,[r3,#0]
;;;191          I2C_delay();	
000028  f7fffffe          BL       I2C_delay
;;;192          if(SDA_read)
00002c  4a09              LDR      r2,|L4.84|
00002e  3a08              SUBS     r2,r2,#8
000030  6812              LDR      r2,[r2,#0]
000032  f4026200          AND      r2,r2,#0x800
000036  b10a              CBZ      r2,|L4.60|
;;;193          {
;;;194            ReceiveByte|=0x01;
000038  f0400001          ORR      r0,r0,#1
                  |L4.60|
00003c  000a              MOVS     r2,r1                 ;185
00003e  f1a10301          SUB      r3,r1,#1              ;185
000042  b2d9              UXTB     r1,r3                 ;185
000044  d1e3              BNE      |L4.14|
;;;195          }
;;;196        }
;;;197        SCL_L;
000046  f44f6280          MOV      r2,#0x400
00004a  4b02              LDR      r3,|L4.84|
00004c  1d1b              ADDS     r3,r3,#4
00004e  601a              STR      r2,[r3,#0]
;;;198        return ReceiveByte;
;;;199    } 
000050  bd00              POP      {pc}
;;;200    //ZRX          
                          ENDP

000052  0000              DCW      0x0000
                  |L4.84|
                          DCD      0x40010c10

                          AREA ||i.I2C_Read||, CODE, READONLY, ALIGN=1

                  I2C_Read PROC
;;;237    
;;;238    void I2C_Read(u8 addr_, u8 reg_, u8 len, u8 *buf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;239    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
;;;240    	u8 i;
;;;241    	 // 起始信号
;;;242    	I2C_Start();
00000c  f7fffffe          BL       I2C_Start
;;;243    	
;;;244    	// 发送设备地址
;;;245    	I2C_SendByte(addr_);   
000010  4638              MOV      r0,r7
000012  f7fffffe          BL       I2C_SendByte
;;;246    	
;;;247    	I2C_WaitAck();
000016  f7fffffe          BL       I2C_WaitAck
;;;248    	
;;;249    	//发送存储单元地址
;;;250    	I2C_SendByte(reg_);                   
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       I2C_SendByte
;;;251    	I2C_WaitAck();
000020  f7fffffe          BL       I2C_WaitAck
;;;252    	
;;;253    	// 起始信号
;;;254    	I2C_Start();
000024  f7fffffe          BL       I2C_Start
;;;255    
;;;256    	//发送设备地址+读信号
;;;257    	I2C_SendByte(addr_+1);     
000028  1c79              ADDS     r1,r7,#1
00002a  b2c8              UXTB     r0,r1
00002c  f7fffffe          BL       I2C_SendByte
;;;258    	I2C_WaitAck();
000030  f7fffffe          BL       I2C_WaitAck
;;;259    	for (i=0; i<len; i++)                   //连续读取6个地址数据，存储中BUF
000034  2400              MOVS     r4,#0
000036  e00d              B        |L5.84|
                  |L5.56|
;;;260    	{
;;;261    		*(buf+i) = I2C_RadeByte();          //BUF[0]存储数据
000038  f7fffffe          BL       I2C_RadeByte
00003c  f8080004          STRB     r0,[r8,r4]
;;;262    		if (i == len-1)		I2C_NoAck();                   //最后一个数据需要回NOACK
000040  1e68              SUBS     r0,r5,#1
000042  42a0              CMP      r0,r4
000044  d102              BNE      |L5.76|
000046  f7fffffe          BL       I2C_NoAck
00004a  e001              B        |L5.80|
                  |L5.76|
;;;263    		else		I2C_Ack();                     //回应ACK
00004c  f7fffffe          BL       I2C_Ack
                  |L5.80|
000050  1c60              ADDS     r0,r4,#1              ;259
000052  b2c4              UXTB     r4,r0                 ;259
                  |L5.84|
000054  42ac              CMP      r4,r5                 ;259
000056  dbef              BLT      |L5.56|
;;;264    	}
;;;265    	I2C_Stop();                           //停止信号
000058  f7fffffe          BL       I2C_Stop
;;;266    	I2C_delay();
00005c  f7fffffe          BL       I2C_delay
;;;267    }
000060  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.I2C_SendByte||, CODE, READONLY, ALIGN=2

                  I2C_SendByte PROC
;;;153    ****************************************************************************** */
;;;154    void I2C_SendByte(unsigned char SendByte) //数据从高位到低位//
000000  b500              PUSH     {lr}
;;;155    {
;;;156        u8 i=8;
000002  2108              MOVS     r1,#8
;;;157        while(i--)
000004  e01d              B        |L6.66|
                  |L6.6|
;;;158        {
;;;159            SCL_L;
000006  f44f6280          MOV      r2,#0x400
00000a  4b13              LDR      r3,|L6.88|
00000c  601a              STR      r2,[r3,#0]
;;;160            I2C_delay();
00000e  f7fffffe          BL       I2C_delay
;;;161          if(SendByte&0x80)
000012  f0000280          AND      r2,r0,#0x80
000016  b12a              CBZ      r2,|L6.36|
;;;162            SDA_H;  
000018  f44f6200          MOV      r2,#0x800
00001c  4b0e              LDR      r3,|L6.88|
00001e  1f1b              SUBS     r3,r3,#4
000020  601a              STR      r2,[r3,#0]
000022  e003              B        |L6.44|
                  |L6.36|
;;;163          else 
;;;164            SDA_L;   
000024  f44f6200          MOV      r2,#0x800
000028  4b0b              LDR      r3,|L6.88|
00002a  601a              STR      r2,[r3,#0]
                  |L6.44|
;;;165            SendByte<<=1;
00002c  0642              LSLS     r2,r0,#25
00002e  0e10              LSRS     r0,r2,#24
;;;166            I2C_delay();
000030  f7fffffe          BL       I2C_delay
;;;167    		SCL_H;
000034  f44f6280          MOV      r2,#0x400
000038  4b07              LDR      r3,|L6.88|
00003a  1f1b              SUBS     r3,r3,#4
00003c  601a              STR      r2,[r3,#0]
;;;168            I2C_delay();
00003e  f7fffffe          BL       I2C_delay
                  |L6.66|
000042  000a              MOVS     r2,r1                 ;157
000044  f1a10301          SUB      r3,r1,#1              ;157
000048  b2d9              UXTB     r1,r3                 ;157
00004a  d1dc              BNE      |L6.6|
;;;169        }
;;;170        SCL_L;
00004c  f44f6280          MOV      r2,#0x400
000050  4b01              LDR      r3,|L6.88|
000052  601a              STR      r2,[r3,#0]
;;;171    }  
000054  bd00              POP      {pc}
;;;172    /*******************************************************************************
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      0x40010c14

                          AREA ||i.I2C_Start||, CODE, READONLY, ALIGN=2

                  I2C_Start PROC
;;;54     ****************************************************************************** */
;;;55     uint16_t I2C_Start(void)
000000  b500              PUSH     {lr}
;;;56     {
;;;57     	SDA_H;
000002  f44f6000          MOV      r0,#0x800
000006  4915              LDR      r1,|L7.92|
000008  6008              STR      r0,[r1,#0]
;;;58     	SCL_H;
00000a  1040              ASRS     r0,r0,#1
00000c  6008              STR      r0,[r1,#0]
;;;59     	I2C_delay();
00000e  f7fffffe          BL       I2C_delay
;;;60     	if(!SDA_read)return FALSE;	//SDA线为低电平则总线忙,退出
000012  4812              LDR      r0,|L7.92|
000014  3808              SUBS     r0,r0,#8
000016  6800              LDR      r0,[r0,#0]
000018  b908              CBNZ     r0,|L7.30|
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L7.32|
                  |L7.30|
00001e  2000              MOVS     r0,#0
                  |L7.32|
000020  f4006000          AND      r0,r0,#0x800
000024  b108              CBZ      r0,|L7.42|
000026  2000              MOVS     r0,#0
                  |L7.40|
;;;61     	SDA_L;
;;;62     	I2C_delay();
;;;63     	if(SDA_read) return FALSE;	//SDA线为高电平则总线出错,退出
;;;64     	SDA_L;
;;;65     	I2C_delay();
;;;66     	return TRUE;
;;;67     }
000028  bd00              POP      {pc}
                  |L7.42|
00002a  f44f6000          MOV      r0,#0x800             ;61
00002e  490b              LDR      r1,|L7.92|
000030  1d09              ADDS     r1,r1,#4              ;61
000032  6008              STR      r0,[r1,#0]            ;61
000034  f7fffffe          BL       I2C_delay
000038  4808              LDR      r0,|L7.92|
00003a  3808              SUBS     r0,r0,#8              ;63
00003c  6800              LDR      r0,[r0,#0]            ;63
00003e  f4006000          AND      r0,r0,#0x800          ;63
000042  b108              CBZ      r0,|L7.72|
000044  2000              MOVS     r0,#0                 ;63
000046  e7ef              B        |L7.40|
                  |L7.72|
000048  f44f6000          MOV      r0,#0x800             ;64
00004c  4903              LDR      r1,|L7.92|
00004e  1d09              ADDS     r1,r1,#4              ;64
000050  6008              STR      r0,[r1,#0]            ;64
000052  f7fffffe          BL       I2C_delay
000056  2001              MOVS     r0,#1                 ;66
000058  e7e6              B        |L7.40|
;;;68     /*******************************************************************************
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      0x40010c10

                          AREA ||i.I2C_Stop||, CODE, READONLY, ALIGN=2

                  I2C_Stop PROC
;;;74     ****************************************************************************** */
;;;75     void I2C_Stop(void)
000000  b500              PUSH     {lr}
;;;76     {
;;;77     	SCL_L;
000002  f44f6080          MOV      r0,#0x400
000006  490c              LDR      r1,|L8.56|
000008  6008              STR      r0,[r1,#0]
;;;78     	I2C_delay();
00000a  f7fffffe          BL       I2C_delay
;;;79     	SDA_L;
00000e  f44f6000          MOV      r0,#0x800
000012  4909              LDR      r1,|L8.56|
000014  6008              STR      r0,[r1,#0]
;;;80     	I2C_delay();
000016  f7fffffe          BL       I2C_delay
;;;81     	SCL_H;
00001a  f44f6080          MOV      r0,#0x400
00001e  4906              LDR      r1,|L8.56|
000020  1f09              SUBS     r1,r1,#4
000022  6008              STR      r0,[r1,#0]
;;;82     	I2C_delay();
000024  f7fffffe          BL       I2C_delay
;;;83     	SDA_H;
000028  f44f6000          MOV      r0,#0x800
00002c  4902              LDR      r1,|L8.56|
00002e  1f09              SUBS     r1,r1,#4
000030  6008              STR      r0,[r1,#0]
;;;84     	I2C_delay();
000032  f7fffffe          BL       I2C_delay
;;;85     } 
000036  bd00              POP      {pc}
;;;86     /*******************************************************************************
                          ENDP

                  |L8.56|
                          DCD      0x40010c14

                          AREA ||i.I2C_WaitAck||, CODE, READONLY, ALIGN=2

                  I2C_WaitAck PROC
;;;128    ****************************************************************************** */
;;;129    uint16_t I2C_WaitAck(void) 	 //返回为:=1有ACK,=0无ACK
000000  b500              PUSH     {lr}
;;;130    {
;;;131    	SCL_L;
000002  f44f6080          MOV      r0,#0x400
000006  4914              LDR      r1,|L9.88|
000008  6008              STR      r0,[r1,#0]
;;;132    	I2C_delay();
00000a  f7fffffe          BL       I2C_delay
;;;133    	SDA_H;			
00000e  f44f6000          MOV      r0,#0x800
000012  4911              LDR      r1,|L9.88|
000014  1f09              SUBS     r1,r1,#4
000016  6008              STR      r0,[r1,#0]
;;;134    	I2C_delay();
000018  f7fffffe          BL       I2C_delay
;;;135    	SCL_H;
00001c  f44f6080          MOV      r0,#0x400
000020  490d              LDR      r1,|L9.88|
000022  1f09              SUBS     r1,r1,#4
000024  6008              STR      r0,[r1,#0]
;;;136    	I2C_delay();
000026  f7fffffe          BL       I2C_delay
;;;137    	if(SDA_read)
00002a  480b              LDR      r0,|L9.88|
00002c  380c              SUBS     r0,r0,#0xc
00002e  6800              LDR      r0,[r0,#0]
000030  f4006000          AND      r0,r0,#0x800
000034  b138              CBZ      r0,|L9.70|
;;;138    	{
;;;139          SCL_L;
000036  f44f6080          MOV      r0,#0x400
00003a  4907              LDR      r1,|L9.88|
00003c  6008              STR      r0,[r1,#0]
;;;140    	  I2C_delay();
00003e  f7fffffe          BL       I2C_delay
;;;141          return FALSE;
000042  2000              MOVS     r0,#0
                  |L9.68|
;;;142    	}
;;;143    	SCL_L;
;;;144    	I2C_delay();
;;;145    	return TRUE;
;;;146    }
000044  bd00              POP      {pc}
                  |L9.70|
000046  f44f6080          MOV      r0,#0x400             ;143
00004a  4903              LDR      r1,|L9.88|
00004c  6008              STR      r0,[r1,#0]            ;143
00004e  f7fffffe          BL       I2C_delay
000052  2001              MOVS     r0,#1                 ;145
000054  e7f6              B        |L9.68|
;;;147    /*******************************************************************************
                          ENDP

000056  0000              DCW      0x0000
                  |L9.88|
                          DCD      0x40010c14

                          AREA ||i.I2C_delay||, CODE, READONLY, ALIGN=1

                  I2C_delay PROC
;;;34     ****************************************************************************** */
;;;35     void I2C_delay(void)
000000  bf00              NOP      
;;;36     {
;;;37     	__NOP();
;;;38     }
000002  4770              BX       lr
;;;39     
                          ENDP


                          AREA ||i.Single_Read||, CODE, READONLY, ALIGN=1

                  Single_Read PROC
;;;218    //单字节读取*****************************************
;;;219    unsigned char Single_Read(unsigned char SlaveAddress,unsigned char REG_Address)
000000  b570              PUSH     {r4-r6,lr}
;;;220    {  
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;221    	unsigned char REG_data;     	
;;;222    	if(!I2C_Start())return FALSE;
000006  f7fffffe          BL       I2C_Start
00000a  b908              CBNZ     r0,|L11.16|
00000c  2000              MOVS     r0,#0
                  |L11.14|
;;;223        I2C_SendByte(SlaveAddress); //I2C_SendByte(((REG_Address & 0x0700) >>7) | REG_Address & 0xFFFE);//设置高起始地址+器件地址 
;;;224        if(!I2C_WaitAck()){I2C_Stop();return FALSE;}
;;;225        I2C_SendByte((u8) REG_Address);   //设置低起始地址      
;;;226        I2C_WaitAck();
;;;227        I2C_Start();
;;;228        I2C_SendByte(SlaveAddress+1);
;;;229        I2C_WaitAck();
;;;230    
;;;231    	  REG_data= I2C_RadeByte();
;;;232        I2C_NoAck();
;;;233        I2C_Stop();
;;;234        //return TRUE;
;;;235    	return REG_data;
;;;236    }	
00000e  bd70              POP      {r4-r6,pc}
                  |L11.16|
000010  4620              MOV      r0,r4                 ;223
000012  f7fffffe          BL       I2C_SendByte
000016  f7fffffe          BL       I2C_WaitAck
00001a  b918              CBNZ     r0,|L11.36|
00001c  f7fffffe          BL       I2C_Stop
000020  2000              MOVS     r0,#0                 ;224
000022  e7f4              B        |L11.14|
                  |L11.36|
000024  4628              MOV      r0,r5                 ;225
000026  f7fffffe          BL       I2C_SendByte
00002a  f7fffffe          BL       I2C_WaitAck
00002e  f7fffffe          BL       I2C_Start
000032  1c61              ADDS     r1,r4,#1              ;228
000034  b2c8              UXTB     r0,r1                 ;228
000036  f7fffffe          BL       I2C_SendByte
00003a  f7fffffe          BL       I2C_WaitAck
00003e  f7fffffe          BL       I2C_RadeByte
000042  4606              MOV      r6,r0                 ;231
000044  f7fffffe          BL       I2C_NoAck
000048  f7fffffe          BL       I2C_Stop
00004c  4630              MOV      r0,r6                 ;235
00004e  e7de              B        |L11.14|
;;;237    
                          ENDP


                          AREA ||i.Single_Write||, CODE, READONLY, ALIGN=1

                  Single_Write PROC
;;;202    
;;;203    uint16_t Single_Write(unsigned char SlaveAddress,unsigned char REG_Address,unsigned char REG_data)		     //void
000000  b570              PUSH     {r4-r6,lr}
;;;204    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;205      	if(!I2C_Start())return FALSE;
000008  f7fffffe          BL       I2C_Start
00000c  b908              CBNZ     r0,|L12.18|
00000e  2000              MOVS     r0,#0
                  |L12.16|
;;;206        I2C_SendByte(SlaveAddress);   //发送设备地址+写信号//I2C_SendByte(((REG_Address & 0x0700) >>7) | SlaveAddress & 0xFFFE);//设置高起始地址+器件地址 
;;;207        if(!I2C_WaitAck()){I2C_Stop(); return FALSE;}
;;;208        I2C_SendByte(REG_Address );   //设置低起始地址      
;;;209        I2C_WaitAck();	
;;;210        I2C_SendByte(REG_data);
;;;211        I2C_WaitAck();   
;;;212        I2C_Stop(); 
;;;213        delay5ms();
;;;214        return TRUE;
;;;215    }
000010  bd70              POP      {r4-r6,pc}
                  |L12.18|
000012  4630              MOV      r0,r6                 ;206
000014  f7fffffe          BL       I2C_SendByte
000018  f7fffffe          BL       I2C_WaitAck
00001c  b918              CBNZ     r0,|L12.38|
00001e  f7fffffe          BL       I2C_Stop
000022  2000              MOVS     r0,#0                 ;207
000024  e7f4              B        |L12.16|
                  |L12.38|
000026  4620              MOV      r0,r4                 ;208
000028  f7fffffe          BL       I2C_SendByte
00002c  f7fffffe          BL       I2C_WaitAck
000030  4628              MOV      r0,r5                 ;210
000032  f7fffffe          BL       I2C_SendByte
000036  f7fffffe          BL       I2C_WaitAck
00003a  f7fffffe          BL       I2C_Stop
00003e  f7fffffe          BL       delay5ms
000042  2001              MOVS     r0,#1                 ;214
000044  e7e4              B        |L12.16|
;;;216    
                          ENDP


                          AREA ||i.delay5ms||, CODE, READONLY, ALIGN=1

                  delay5ms PROC
;;;39     
;;;40     void delay5ms(void)
000000  f2413088          MOV      r0,#0x1388
;;;41     {	
;;;42        int i=5000;  
;;;43        while(i) 
000004  e000              B        |L13.8|
                  |L13.6|
;;;44        { 
;;;45          i--; 
000006  1e40              SUBS     r0,r0,#1
                  |L13.8|
000008  2800              CMP      r0,#0                 ;43
00000a  d1fc              BNE      |L13.6|
;;;46        }  
;;;47     }
00000c  4770              BX       lr
;;;48     /*******************************************************************************
                          ENDP

