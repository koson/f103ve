; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_it.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Driver\STMFLASH -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Driver\Modules_hmc5883 -I..\..\User\Driver\Modules_mpu6050 -I..\..\User\Driver\Modules_ms5611 -I..\..\User\Driver\Modules_oled -I..\..\User\Driver\Modules_ultrasonic -I..\..\User\Function\Heigh -I"C:\Users\Administrator\Desktop\机器人课飞控\机器人课无人机原始程序 - 副本\Project\MDK-ARM(uV5)\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\stm32f10x_it.crf ..\..\User\stm32f10x_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
;;;114    */    
;;;115    void BusFault_Handler(void)
000000  bf00              NOP      
                  |L1.2|
;;;116    {
;;;117      /* 当总线异常时进入死循环 */
;;;118      while (1)
000002  e7fe              B        |L1.2|
;;;119      {
;;;120      }
;;;121    }
;;;122    
                          ENDP


                          AREA ||i.DMA1_Channel4_IRQHandler||, CODE, READONLY, ALIGN=2

                  DMA1_Channel4_IRQHandler PROC
;;;48     //串口1  DMA方式发送中断  
;;;49     void DMA1_Channel4_IRQHandler(void)  
000000  b510              PUSH     {r4,lr}
;;;50     {   
;;;51       //清除标志位  
;;;52        DMA_ClearFlag(DMA1_FLAG_TC4);   
000002  f44f5000          MOV      r0,#0x2000
000006  f7fffffe          BL       DMA_ClearFlag
;;;53     	 Flag_Uart_Send=0;                    
00000a  2000              MOVS     r0,#0
00000c  4901              LDR      r1,|L2.20|
00000e  7008              STRB     r0,[r1,#0]
;;;54     } 
000010  bd10              POP      {r4,pc}
;;;55     
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      Flag_Uart_Send

                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;158    */   
;;;159    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;160    {
;;;161    }
;;;162    
                          ENDP


                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
;;;82     */ 
;;;83     void HardFault_Handler(void)
000000  bf00              NOP      
                  |L4.2|
;;;84     {
;;;85       /* 当硬件失效异常发生时进入死循环 */
;;;86       while (1)
000002  e7fe              B        |L4.2|
;;;87       {
;;;88       }
;;;89     }
;;;90     
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
;;;98     */   
;;;99     void MemManage_Handler(void)
000000  bf00              NOP      
                  |L5.2|
;;;100    {
;;;101      /* 当内存管理异常发生时进入死循环 */
;;;102      while (1)
000002  e7fe              B        |L5.2|
;;;103      {
;;;104      }
;;;105    }
;;;106    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;70     */  
;;;71     void NMI_Handler(void)
000000  4770              BX       lr
;;;72     {
;;;73     }
;;;74     
                          ENDP


                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;170    */     
;;;171    void PendSV_Handler(void)
000000  4770              BX       lr
;;;172    {
;;;173    }
;;;174    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;146    */   
;;;147    void SVC_Handler(void)
000000  4770              BX       lr
;;;148    {
;;;149    }
;;;150    
                          ENDP


                          AREA ||i.TIM5_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM5_IRQHandler PROC
;;;1      #ifndef __INCLUDE_H
;;;4      void TIM5_IRQHandler(void)		    //2.5ms中断一次
000000  b510              PUSH     {r4,lr}
;;;5      {	
;;;6      	if(TIM5->SR & TIM_IT_Update)	{    
000002  4816              LDR      r0,|L9.92|
000004  8800              LDRH     r0,[r0,#0]
000006  f0000001          AND      r0,r0,#1
00000a  b330              CBZ      r0,|L9.90|
;;;7          TIM5->SR = ~TIM_FLAG_Update;
00000c  f64f70fe          MOV      r0,#0xfffe
000010  4912              LDR      r1,|L9.92|
000012  8008              STRH     r0,[r1,#0]
;;;8       
;;;9      		realtime++;
000014  f04f517e          MOV      r1,#0x3f800000
000018  4811              LDR      r0,|L9.96|
00001a  6800              LDR      r0,[r0,#0]  ; realtime
00001c  f7fffffe          BL       __aeabi_fadd
000020  490f              LDR      r1,|L9.96|
000022  6008              STR      r0,[r1,#0]  ; realtime
;;;10     
;;;11      		testtime=TIM5->CNT;
000024  480d              LDR      r0,|L9.92|
000026  3014              ADDS     r0,r0,#0x14
000028  8800              LDRH     r0,[r0,#0]
00002a  490e              LDR      r1,|L9.100|
00002c  8008              STRH     r0,[r1,#0]
;;;12     		Time_slice();//2us		
00002e  f7fffffe          BL       Time_slice
;;;13     		RDAU();//62us对接收的遥控通道值进行处理，包含解锁、校准等动作解析	
000032  f7fffffe          BL       RDAU
;;;14     		AHRS_Geteuler();//1650us，其中地磁占用310us		
000036  f7fffffe          BL       AHRS_Geteuler
;;;15     		Calculate_Target();	//5us
00003a  f7fffffe          BL       Calculate_Target
;;;16     		Altitute_calculate();//180+200us			
00003e  f7fffffe          BL       Altitute_calculate
;;;17     		CONTROL(Target);//65us
000042  4809              LDR      r0,|L9.104|
000044  c80f              LDM      r0,{r0-r3}
000046  f7fffffe          BL       CONTROL
;;;18      	  testtime=TIM5->CNT-testtime;  
00004a  4804              LDR      r0,|L9.92|
00004c  3014              ADDS     r0,r0,#0x14
00004e  8800              LDRH     r0,[r0,#0]
000050  4904              LDR      r1,|L9.100|
000052  8809              LDRH     r1,[r1,#0]  ; testtime
000054  1a40              SUBS     r0,r0,r1
000056  4903              LDR      r1,|L9.100|
000058  8008              STRH     r0,[r1,#0]
                  |L9.90|
;;;19     	}
;;;20     }
00005a  bd10              POP      {r4,pc}
;;;21     
                          ENDP

                  |L9.92|
                          DCD      0x40000c10
                  |L9.96|
                          DCD      realtime
                  |L9.100|
                          DCD      testtime
                  |L9.104|
                          DCD      Target

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;27     
;;;28     void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;29     {
;;;30     	u8 com_data;
;;;31     	
;;;32     	if( USART_GetITStatus(USART1,USART_IT_RXNE) )
000002  f2405125          MOV      r1,#0x525
000006  4810              LDR      r0,|L10.72|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b180              CBZ      r0,|L10.48|
;;;33     	{
;;;34     		USART_ClearITPendingBit(USART1,USART_IT_RXNE);//清除中断标志
00000e  f2405125          MOV      r1,#0x525
000012  480d              LDR      r0,|L10.72|
000014  f7fffffe          BL       USART_ClearITPendingBit
;;;35     
;;;36     		com_data = USART1->DR;
000018  480b              LDR      r0,|L10.72|
00001a  1d00              ADDS     r0,r0,#4
00001c  8800              LDRH     r0,[r0,#0]
00001e  b2c4              UXTB     r4,r0
;;;37     		Rx_Buf[Rxcounter++]=com_data;
000020  480a              LDR      r0,|L10.76|
000022  7801              LDRB     r1,[r0,#0]  ; Rxcounter
000024  7800              LDRB     r0,[r0,#0]  ; Rxcounter
000026  1c40              ADDS     r0,r0,#1
000028  4a08              LDR      r2,|L10.76|
00002a  7010              STRB     r0,[r2,#0]
00002c  4808              LDR      r0,|L10.80|
00002e  5444              STRB     r4,[r0,r1]
                  |L10.48|
;;;38     	}
;;;39     	
;;;40     	//发送（进入移位）中断，不使用，其实没有打开发送中断的。
;;;41     	if( USART_GetITStatus(USART1,USART_IT_TXE ) )
000030  f2407127          MOV      r1,#0x727
000034  4804              LDR      r0,|L10.72|
000036  f7fffffe          BL       USART_GetITStatus
00003a  b120              CBZ      r0,|L10.70|
;;;42     	{
;;;43     		USART_ClearITPendingBit(USART1,USART_IT_TXE);//清除发送中断标志
00003c  f2407127          MOV      r1,#0x727
000040  4801              LDR      r0,|L10.72|
000042  f7fffffe          BL       USART_ClearITPendingBit
                  |L10.70|
;;;44     	}
;;;45     }
000046  bd10              POP      {r4,pc}
;;;46     
                          ENDP

                  |L10.72|
                          DCD      0x40013800
                  |L10.76|
                          DCD      Rxcounter
                  |L10.80|
                          DCD      Rx_Buf

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
;;;130    */   
;;;131    void UsageFault_Handler(void)
000000  bf00              NOP      
                  |L11.2|
;;;132    {
;;;133      /* 当用法异常时进入死循环 */
;;;134      while (1)
000002  e7fe              B        |L11.2|
;;;135      {
;;;136      }
;;;137    }
;;;138    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  TxBuffer
                          %        256
                  Rx_Buf
                          %        256

                          AREA ||.data||, DATA, ALIGN=0

                  TxCounter
000000  00                DCB      0x00
                  count
000001  00                DCB      0x00
                  Rxcounter
000002  00                DCB      0x00
                  count_rx
000003  00                DCB      0x00
