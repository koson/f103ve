; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usart.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\User\usb_virture_com -I..\..\User -I..\..\User\bsp -I..\..\User\Driver\IIC -I..\..\User\Driver\LED -I..\..\User\Driver\TIM -I..\..\User\Driver\Delay -I..\..\User\Driver\UART -I..\..\User\Driver\MOTOR -I..\..\User\Driver\PWM_IN -I..\..\User\Driver\EEPROM -I..\..\User\Algorithm\Algorithm_filter -I..\..\User\Algorithm\Algorithm_math -I..\..\User\Algorithm\Algorithm_sqLite -I..\..\User\Algorithm\Algorithm_quaternion -I..\..\User\Function\MultiRotor_rc -I..\..\User\Function\MultiRotor_app -I..\..\User\Function\MultiRotor_ahrs -I..\..\User\Function\MultiRotor_radio -I..\..\User\Function\MultiRotor_control -I..\..\User\Driver\STMFLASH -I..\..\User\Function\MultiRotor_altitute -I..\..\User\Modules\Modules_ultrasonic -I..\..\User\ANO_DT -I..\..\User\Driver\Modules_hmc5883 -I..\..\User\Driver\Modules_mpu6050 -I..\..\User\Driver\Modules_ms5611 -I..\..\User\Driver\Modules_oled -I..\..\User\Driver\Modules_ultrasonic -I..\..\User\Function\Heigh -I"C:\Users\Administrator\Desktop\机器人课飞控\机器人课无人机原始程序 - 副本\Project\MDK-ARM(uV5)\RTE" -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\usart.crf ..\..\User\Driver\UART\usart.c]
                          THUMB

                          AREA ||i.DMA_USART1_Configuration||, CODE, READONLY, ALIGN=2

                  DMA_USART1_Configuration PROC
;;;47     
;;;48     void DMA_USART1_Configuration(void)
000000  b500              PUSH     {lr}
;;;49     {
000002  b08b              SUB      sp,sp,#0x2c
;;;50     	DMA_InitTypeDef DMA_InitStructure;
;;;51     
;;;52     	DMA_DeInit(DMA1_Channel4);
000004  4814              LDR      r0,|L1.88|
000006  f7fffffe          BL       DMA_DeInit
;;;53     	DMA_InitStructure.DMA_PeripheralBaseAddr = USART1_DR_Base;//已经宏定义了，内存地址&串口数据寄存器地址
00000a  4814              LDR      r0,|L1.92|
00000c  9000              STR      r0,[sp,#0]
;;;54     	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)sendbuf;  //这个地址无所谓，后边发送的时候会重新赋值。
00000e  4814              LDR      r0,|L1.96|
000010  9001              STR      r0,[sp,#4]
;;;55     	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
000012  2010              MOVS     r0,#0x10
000014  9002              STR      r0,[sp,#8]
;;;56     	DMA_InitStructure.DMA_BufferSize = datanum; //传输数据大小
000016  4813              LDR      r0,|L1.100|
000018  7800              LDRB     r0,[r0,#0]  ; datanum
00001a  9003              STR      r0,[sp,#0xc]
;;;57     	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
00001c  2000              MOVS     r0,#0
00001e  9004              STR      r0,[sp,#0x10]
;;;58     	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
000020  2080              MOVS     r0,#0x80
000022  9005              STR      r0,[sp,#0x14]
;;;59     	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
000024  2000              MOVS     r0,#0
000026  9006              STR      r0,[sp,#0x18]
;;;60     	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
000028  9007              STR      r0,[sp,#0x1c]
;;;61     	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;//DMA模式一次传输，不循环;DMA_Mode_Circular//
00002a  9008              STR      r0,[sp,#0x20]
;;;62     	DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;//优先级中
00002c  f44f5080          MOV      r0,#0x1000
000030  9009              STR      r0,[sp,#0x24]
;;;63     	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
000032  2000              MOVS     r0,#0
000034  900a              STR      r0,[sp,#0x28]
;;;64     	DMA_Init(DMA1_Channel4, &DMA_InitStructure);
000036  4669              MOV      r1,sp
000038  4807              LDR      r0,|L1.88|
00003a  f7fffffe          BL       DMA_Init
;;;65     
;;;66     	/* Enable DMA1 Channel4Transfer Complete interrupt */  
;;;67     	DMA_ITConfig(DMA1_Channel4,DMA_IT_TC, ENABLE);   
00003e  2201              MOVS     r2,#1
000040  2102              MOVS     r1,#2
000042  4805              LDR      r0,|L1.88|
000044  f7fffffe          BL       DMA_ITConfig
;;;68       //USART_DMACmd(USART1,USART_DMAReq_Rx,ENABLE);    //不需要DMA方式接收                                                                //串口接收器DMA  
;;;69       //采用DMA方式发送  
;;;70     	USART_DMACmd(USART1,USART_DMAReq_Tx,ENABLE);  //使能串口1的DMA发送 
000048  2201              MOVS     r2,#1
00004a  2180              MOVS     r1,#0x80
00004c  4803              LDR      r0,|L1.92|
00004e  1f00              SUBS     r0,r0,#4
000050  f7fffffe          BL       USART_DMACmd
;;;71     }
000054  b00b              ADD      sp,sp,#0x2c
000056  bd00              POP      {pc}
;;;72     
                          ENDP

                  |L1.88|
                          DCD      0x40020044
                  |L1.92|
                          DCD      0x40013804
                  |L1.96|
                          DCD      sendbuf
                  |L1.100|
                          DCD      datanum

                          AREA ||i.UART1_Put_Char||, CODE, READONLY, ALIGN=2

                  UART1_Put_Char PROC
;;;80     *******************************************************************************/
;;;81     uint8_t UART1_Put_Char(unsigned char DataToSend)
000000  b510              PUSH     {r4,lr}
;;;82     {
000002  4604              MOV      r4,r0
;;;83     	//将要发送的字节写到UART1的发送缓冲区
;;;84     	USART_SendData(USART1, (unsigned char) DataToSend);
000004  4621              MOV      r1,r4
000006  4806              LDR      r0,|L2.32|
000008  f7fffffe          BL       USART_SendData
;;;85     	//等待发送完成
;;;86       	while (!(USART1->SR & USART_FLAG_TXE));
00000c  bf00              NOP      
                  |L2.14|
00000e  4804              LDR      r0,|L2.32|
000010  8800              LDRH     r0,[r0,#0]
000012  f0000080          AND      r0,r0,#0x80
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L2.14|
;;;87     	return DataToSend;
00001a  4620              MOV      r0,r4
;;;88     }
00001c  bd10              POP      {r4,pc}
;;;89     
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x40013800

                          AREA ||i.UART2_Put_Char||, CODE, READONLY, ALIGN=2

                  UART2_Put_Char PROC
;;;268    *******************************************************************************/
;;;269    uint8_t UART2_Put_Char(unsigned char DataToSend)
000000  b510              PUSH     {r4,lr}
;;;270    {
000002  4604              MOV      r4,r0
;;;271    	//将要发送的字节写到UART1的发送缓冲区
;;;272    	USART_SendData(USART2, (unsigned char) DataToSend);
000004  4621              MOV      r1,r4
000006  4806              LDR      r0,|L3.32|
000008  f7fffffe          BL       USART_SendData
;;;273    	//等待发送完成
;;;274      	while (!(USART2->SR & USART_FLAG_TXE));
00000c  bf00              NOP      
                  |L3.14|
00000e  4804              LDR      r0,|L3.32|
000010  8800              LDRH     r0,[r0,#0]
000012  f0000080          AND      r0,r0,#0x80
000016  2800              CMP      r0,#0
000018  d0f9              BEQ      |L3.14|
;;;275    	return DataToSend;
00001a  4620              MOV      r0,r4
;;;276    }
00001c  bd10              POP      {r4,pc}
;;;277    
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      0x40004400

                          AREA ||i.USART1_Config||, CODE, READONLY, ALIGN=2

                  USART1_Config PROC
;;;5      
;;;6      void USART1_Config(void)
000000  b500              PUSH     {lr}
;;;7      {
000002  b085              SUB      sp,sp,#0x14
;;;8      	GPIO_InitTypeDef GPIO_InitStructure;
;;;9      	USART_InitTypeDef USART_InitStructure;
;;;10     	
;;;11     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_AFIO |RCC_APB2Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  f2440005          MOV      r0,#0x4005
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;12     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);//开启DMA1的时钟
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;13     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000016  f44f7000          MOV      r0,#0x200
00001a  f8ad0010          STRH     r0,[sp,#0x10]
;;;14     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2018              MOVS     r0,#0x18
000020  f88d0013          STRB     r0,[sp,#0x13]
;;;15     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
000026  f88d0012          STRB     r0,[sp,#0x12]
;;;16     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00002a  a904              ADD      r1,sp,#0x10
00002c  4817              LDR      r0,|L4.140|
00002e  f7fffffe          BL       GPIO_Init
;;;17     	
;;;18     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000032  f44f6080          MOV      r0,#0x400
000036  f8ad0010          STRH     r0,[sp,#0x10]
;;;19     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2004              MOVS     r0,#4
00003c  f88d0013          STRB     r0,[sp,#0x13]
;;;20     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000040  a904              ADD      r1,sp,#0x10
000042  4812              LDR      r0,|L4.140|
000044  f7fffffe          BL       GPIO_Init
;;;21     	
;;;22     	// 设置波特率
;;;23     	USART_InitStructure.USART_BaudRate = 115200;   
000048  f44f30e1          MOV      r0,#0x1c200
00004c  9000              STR      r0,[sp,#0]
;;;24     	
;;;25     	// 设置数据位为8位
;;;26       USART_InitStructure.USART_WordLength = USART_WordLength_8b; 
00004e  2000              MOVS     r0,#0
000050  f8ad0004          STRH     r0,[sp,#4]
;;;27     
;;;28       // 设置停止位为1位	
;;;29       USART_InitStructure.USART_StopBits = USART_StopBits_1;  
000054  f8ad0006          STRH     r0,[sp,#6]
;;;30     
;;;31       // 无奇偶校验
;;;32       USART_InitStructure.USART_Parity = USART_Parity_No;  
000058  f8ad0008          STRH     r0,[sp,#8]
;;;33     
;;;34       // 没有硬件流控
;;;35       USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; 
00005c  f8ad000c          STRH     r0,[sp,#0xc]
;;;36     	
;;;37     	// 发送与接收
;;;38       USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;     
000060  200c              MOVS     r0,#0xc
000062  f8ad000a          STRH     r0,[sp,#0xa]
;;;39         
;;;40     	/*完成串口COM1的时钟配置、GPIO配置，根据上述参数初始化并使能*/
;;;41     	USART_Init(USART1, &USART_InitStructure);
000066  4669              MOV      r1,sp
000068  4809              LDR      r0,|L4.144|
00006a  f7fffffe          BL       USART_Init
;;;42     	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);////只使用接收中断，不使用发送中断
00006e  2201              MOVS     r2,#1
000070  f2405125          MOV      r1,#0x525
000074  4806              LDR      r0,|L4.144|
000076  f7fffffe          BL       USART_ITConfig
;;;43     	USART_Cmd(USART1, ENABLE);
00007a  2101              MOVS     r1,#1
00007c  4804              LDR      r0,|L4.144|
00007e  f7fffffe          BL       USART_Cmd
;;;44     	DMA_USART1_Configuration();//用DMA有误码待解决
000082  f7fffffe          BL       DMA_USART1_Configuration
;;;45     }
000086  b005              ADD      sp,sp,#0x14
000088  bd00              POP      {pc}
;;;46     
                          ENDP

00008a  0000              DCW      0x0000
                  |L4.140|
                          DCD      0x40010800
                  |L4.144|
                          DCD      0x40013800

                          AREA ||i.USART1_printf||, CODE, READONLY, ALIGN=1

                  USART1_printf PROC
;;;161     */
;;;162    void USART1_printf(USART_TypeDef* USARTx, uint8_t *Data,...)
000000  b40f              PUSH     {r0-r3}
;;;163    {
000002  b570              PUSH     {r4-r6,lr}
000004  b086              SUB      sp,sp,#0x18
000006  4606              MOV      r6,r0
;;;164    	const char *s;
;;;165      int d;   
;;;166      char buf[16];
;;;167    
;;;168      va_list ap;
;;;169      va_start(ap, Data);
000008  a80c              ADD      r0,sp,#0x30
00000a  9001              STR      r0,[sp,#4]
;;;170    
;;;171    	while ( *Data != 0)     // 判断是否到达字符串结束符
00000c  e073              B        |L5.246|
                  |L5.14|
;;;172    	{				                          
;;;173    		if ( *Data == 0x5c )  //'\'
00000e  980b              LDR      r0,[sp,#0x2c]
000010  7800              LDRB     r0,[r0,#0]
000012  285c              CMP      r0,#0x5c
000014  d11c              BNE      |L5.80|
;;;174    		{									  
;;;175    			switch ( *++Data )
000016  980b              LDR      r0,[sp,#0x2c]
000018  1c40              ADDS     r0,r0,#1
00001a  900b              STR      r0,[sp,#0x2c]
00001c  7800              LDRB     r0,[r0,#0]
00001e  286e              CMP      r0,#0x6e
000020  d009              BEQ      |L5.54|
000022  2872              CMP      r0,#0x72
000024  d10f              BNE      |L5.70|
;;;176    			{
;;;177    				case 'r':							          //回车符
;;;178    					USART_SendData(USARTx, 0x0d);
000026  210d              MOVS     r1,#0xd
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       USART_SendData
;;;179    					Data ++;
00002e  980b              LDR      r0,[sp,#0x2c]
000030  1c40              ADDS     r0,r0,#1
000032  900b              STR      r0,[sp,#0x2c]
;;;180    					break;
000034  e00b              B        |L5.78|
                  |L5.54|
;;;181    
;;;182    				case 'n':							          //换行符
;;;183    					USART_SendData(USARTx, 0x0a);	
000036  210a              MOVS     r1,#0xa
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       USART_SendData
;;;184    					Data ++;
00003e  980b              LDR      r0,[sp,#0x2c]
000040  1c40              ADDS     r0,r0,#1
000042  900b              STR      r0,[sp,#0x2c]
;;;185    					break;
000044  e003              B        |L5.78|
                  |L5.70|
;;;186    				
;;;187    				default:
;;;188    					Data ++;
000046  980b              LDR      r0,[sp,#0x2c]
000048  1c40              ADDS     r0,r0,#1
00004a  900b              STR      r0,[sp,#0x2c]
;;;189    				    break;
00004c  bf00              NOP      
                  |L5.78|
00004e  e04b              B        |L5.232|
                  |L5.80|
;;;190    			}			 
;;;191    		}
;;;192    		else if ( *Data == '%')
000050  980b              LDR      r0,[sp,#0x2c]
000052  7800              LDRB     r0,[r0,#0]
000054  2825              CMP      r0,#0x25
000056  d140              BNE      |L5.218|
;;;193    		{									  //
;;;194    			switch ( *++Data )
000058  980b              LDR      r0,[sp,#0x2c]
00005a  1c40              ADDS     r0,r0,#1
00005c  900b              STR      r0,[sp,#0x2c]
00005e  7800              LDRB     r0,[r0,#0]
000060  2864              CMP      r0,#0x64
000062  d018              BEQ      |L5.150|
000064  2873              CMP      r0,#0x73
000066  d133              BNE      |L5.208|
;;;195    			{				
;;;196    				case 's':										  //字符串
;;;197    					s = va_arg(ap, const char *);
000068  9801              LDR      r0,[sp,#4]
00006a  c810              LDM      r0!,{r4}
00006c  9001              STR      r0,[sp,#4]
;;;198              for ( ; *s; s++) 
00006e  e00b              B        |L5.136|
                  |L5.112|
;;;199    					{
;;;200    						USART_SendData(USARTx,*s);
000070  7821              LDRB     r1,[r4,#0]
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       USART_SendData
;;;201    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
000078  bf00              NOP      
                  |L5.122|
00007a  2140              MOVS     r1,#0x40
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       USART_GetFlagStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L5.122|
000086  1c64              ADDS     r4,r4,#1              ;198
                  |L5.136|
000088  7820              LDRB     r0,[r4,#0]            ;198
00008a  2800              CMP      r0,#0                 ;198
00008c  d1f0              BNE      |L5.112|
;;;202              }
;;;203    					Data++;
00008e  980b              LDR      r0,[sp,#0x2c]
000090  1c40              ADDS     r0,r0,#1
000092  900b              STR      r0,[sp,#0x2c]
;;;204              break;
000094  e020              B        |L5.216|
                  |L5.150|
;;;205    
;;;206            case 'd':										//十进制
;;;207              d = va_arg(ap, int);
000096  9801              LDR      r0,[sp,#4]
000098  c820              LDM      r0!,{r5}
00009a  9001              STR      r0,[sp,#4]
;;;208              itoa(d, buf, 10);
00009c  220a              MOVS     r2,#0xa
00009e  a902              ADD      r1,sp,#8
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       itoa
;;;209              for (s = buf; *s; s++) 
0000a6  ac02              ADD      r4,sp,#8
0000a8  e00b              B        |L5.194|
                  |L5.170|
;;;210    					{
;;;211    						USART_SendData(USARTx,*s);
0000aa  7821              LDRB     r1,[r4,#0]
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       USART_SendData
;;;212    						while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000b2  bf00              NOP      
                  |L5.180|
0000b4  2140              MOVS     r1,#0x40
0000b6  4630              MOV      r0,r6
0000b8  f7fffffe          BL       USART_GetFlagStatus
0000bc  2800              CMP      r0,#0
0000be  d0f9              BEQ      |L5.180|
0000c0  1c64              ADDS     r4,r4,#1              ;209
                  |L5.194|
0000c2  7820              LDRB     r0,[r4,#0]            ;209
0000c4  2800              CMP      r0,#0                 ;209
0000c6  d1f0              BNE      |L5.170|
;;;213              }
;;;214    					Data++;
0000c8  980b              LDR      r0,[sp,#0x2c]
0000ca  1c40              ADDS     r0,r0,#1
0000cc  900b              STR      r0,[sp,#0x2c]
;;;215              break;
0000ce  e003              B        |L5.216|
                  |L5.208|
;;;216    				 default:
;;;217    						Data++;
0000d0  980b              LDR      r0,[sp,#0x2c]
0000d2  1c40              ADDS     r0,r0,#1
0000d4  900b              STR      r0,[sp,#0x2c]
;;;218    				    break;
0000d6  bf00              NOP      
                  |L5.216|
0000d8  e006              B        |L5.232|
                  |L5.218|
;;;219    			}		 
;;;220    		} /* end of else if */
;;;221    		else USART_SendData(USARTx, *Data++);
0000da  980b              LDR      r0,[sp,#0x2c]
0000dc  f8101b01          LDRB     r1,[r0],#1
0000e0  900b              STR      r0,[sp,#0x2c]
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       USART_SendData
                  |L5.232|
;;;222    		while( USART_GetFlagStatus(USARTx, USART_FLAG_TC) == RESET );
0000e8  bf00              NOP      
                  |L5.234|
0000ea  2140              MOVS     r1,#0x40
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       USART_GetFlagStatus
0000f2  2800              CMP      r0,#0
0000f4  d0f9              BEQ      |L5.234|
                  |L5.246|
0000f6  980b              LDR      r0,[sp,#0x2c]         ;171
0000f8  7800              LDRB     r0,[r0,#0]            ;171
0000fa  2800              CMP      r0,#0                 ;171
0000fc  d187              BNE      |L5.14|
;;;223    	}
;;;224    }
0000fe  b006              ADD      sp,sp,#0x18
000100  bc70              POP      {r4-r6}
000102  f85dfb14          LDR      pc,[sp],#0x14
;;;225    
                          ENDP


                          AREA ||i.itoa||, CODE, READONLY, ALIGN=1

                  itoa PROC
;;;100     */
;;;101    static char *itoa(int value, char *string, int radix)
000000  b5f0              PUSH     {r4-r7,lr}
;;;102    {
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;103        int     i, d;
;;;104        int     flag = 0;
000008  2700              MOVS     r7,#0
;;;105        char    *ptr = string;
00000a  4629              MOV      r1,r5
;;;106    
;;;107        /* This implementation only works for decimal numbers. */
;;;108        if (radix != 10)
00000c  2e0a              CMP      r6,#0xa
00000e  d003              BEQ      |L6.24|
;;;109        {
;;;110            *ptr = 0;
000010  2000              MOVS     r0,#0
000012  7008              STRB     r0,[r1,#0]
;;;111            return string;
000014  4628              MOV      r0,r5
                  |L6.22|
;;;112        }
;;;113    
;;;114        if (!value)
;;;115        {
;;;116            *ptr++ = 0x30;
;;;117            *ptr = 0;
;;;118            return string;
;;;119        }
;;;120    
;;;121        /* if this is a negative value insert the minus sign. */
;;;122        if (value < 0)
;;;123        {
;;;124            *ptr++ = '-';
;;;125    
;;;126            /* Make the value positive. */
;;;127            value *= -1;
;;;128        }
;;;129    
;;;130        for (i = 10000; i > 0; i /= 10)
;;;131        {
;;;132            d = value / i;
;;;133    
;;;134            if (d || flag)
;;;135            {
;;;136                *ptr++ = (char)(d + 0x30);
;;;137                value -= (d * i);
;;;138                flag = 1;
;;;139            }
;;;140        }
;;;141    
;;;142        /* Null terminate the string. */
;;;143        *ptr = 0;
;;;144    
;;;145        return string;
;;;146    
;;;147    } /* NCL_Itoa */
000016  bdf0              POP      {r4-r7,pc}
                  |L6.24|
000018  b933              CBNZ     r3,|L6.40|
00001a  2030              MOVS     r0,#0x30              ;116
00001c  f8010b01          STRB     r0,[r1],#1            ;116
000020  2000              MOVS     r0,#0                 ;117
000022  7008              STRB     r0,[r1,#0]            ;117
000024  4628              MOV      r0,r5                 ;118
000026  e7f6              B        |L6.22|
                  |L6.40|
000028  2b00              CMP      r3,#0                 ;122
00002a  da03              BGE      |L6.52|
00002c  202d              MOVS     r0,#0x2d              ;124
00002e  f8010b01          STRB     r0,[r1],#1            ;124
000032  425b              RSBS     r3,r3,#0              ;127
                  |L6.52|
000034  f2427210          MOV      r2,#0x2710            ;130
000038  e00d              B        |L6.86|
                  |L6.58|
00003a  fb93f4f2          SDIV     r4,r3,r2              ;132
00003e  b904              CBNZ     r4,|L6.66|
000040  b137              CBZ      r7,|L6.80|
                  |L6.66|
000042  f1040030          ADD      r0,r4,#0x30           ;136
000046  f8010b01          STRB     r0,[r1],#1            ;136
00004a  fb043312          MLS      r3,r4,r2,r3           ;137
00004e  2701              MOVS     r7,#1                 ;138
                  |L6.80|
000050  200a              MOVS     r0,#0xa               ;130
000052  fb92f2f0          SDIV     r2,r2,r0              ;130
                  |L6.86|
000056  2a00              CMP      r2,#0                 ;130
000058  dcef              BGT      |L6.58|
00005a  2000              MOVS     r0,#0                 ;143
00005c  7008              STRB     r0,[r1,#0]            ;143
00005e  4628              MOV      r0,r5                 ;145
000060  e7d9              B        |L6.22|
;;;148    
                          ENDP


                          AREA ||i.usart2_config||, CODE, READONLY, ALIGN=2

                  usart2_config PROC
;;;226    /**************【目前暂未使用串口2】*******************/
;;;227    void usart2_config(void)
000000  b500              PUSH     {lr}
;;;228    {
000002  b085              SUB      sp,sp,#0x14
;;;229    	GPIO_InitTypeDef GPIO_InitStructure;
;;;230    	USART_InitTypeDef USART_InitStructure;
;;;231    	
;;;232    		/* config USART2 clock */
;;;233    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE);
000004  2101              MOVS     r1,#1
000006  2020              MOVS     r0,#0x20
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;234    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;235      RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);  //使能AFIO功能的时钟
000014  2101              MOVS     r1,#1
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;236      GPIO_PinRemapConfig(GPIO_Remap_USART2 ,ENABLE);  //进行重映射
00001c  2101              MOVS     r1,#1
00001e  2008              MOVS     r0,#8
000020  f7fffffe          BL       GPIO_PinRemapConfig
;;;237    	
;;;238    	
;;;239      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
000024  2020              MOVS     r0,#0x20
000026  f8ad0010          STRH     r0,[sp,#0x10]
;;;240      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00002a  2018              MOVS     r0,#0x18
00002c  f88d0013          STRB     r0,[sp,#0x13]
;;;241      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000030  2003              MOVS     r0,#3
000032  f88d0012          STRB     r0,[sp,#0x12]
;;;242      GPIO_Init(GPIOD, &GPIO_InitStructure);
000036  a904              ADD      r1,sp,#0x10
000038  4815              LDR      r0,|L7.144|
00003a  f7fffffe          BL       GPIO_Init
;;;243    	    
;;;244      /* Configure USART2 Rx (PD.09) as input floating */
;;;245      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00003e  2040              MOVS     r0,#0x40
000040  f8ad0010          STRH     r0,[sp,#0x10]
;;;246      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000044  2004              MOVS     r0,#4
000046  f88d0013          STRB     r0,[sp,#0x13]
;;;247      GPIO_Init(GPIOD, &GPIO_InitStructure);
00004a  a904              ADD      r1,sp,#0x10
00004c  4810              LDR      r0,|L7.144|
00004e  f7fffffe          BL       GPIO_Init
;;;248    	
;;;249    	USART_InitStructure.USART_BaudRate = 9600;                 /*设置波特率为115200*/
000052  f44f5016          MOV      r0,#0x2580
000056  9000              STR      r0,[sp,#0]
;;;250    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;  /*设置数据位为8位*/
000058  2000              MOVS     r0,#0
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;251    	USART_InitStructure.USART_StopBits = USART_StopBits_1;       /*设置停止位为1位*/
00005e  f8ad0006          STRH     r0,[sp,#6]
;;;252    	USART_InitStructure.USART_Parity = USART_Parity_No;          /*无奇偶校验*/    
000062  f8ad0008          STRH     r0,[sp,#8]
;;;253    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; /*没有硬件流控*/
000066  f8ad000c          STRH     r0,[sp,#0xc]
;;;254    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;      /*发送与接收*/
00006a  200c              MOVS     r0,#0xc
00006c  f8ad000a          STRH     r0,[sp,#0xa]
;;;255    	/*完成串口COM3的时钟配置、GPIO配置，根据上述参数初始化并使能*/
;;;256    	
;;;257    	USART_Init(USART2, &USART_InitStructure);
000070  4669              MOV      r1,sp
000072  4808              LDR      r0,|L7.148|
000074  f7fffffe          BL       USART_Init
;;;258    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000078  2201              MOVS     r2,#1
00007a  f2405125          MOV      r1,#0x525
00007e  4805              LDR      r0,|L7.148|
000080  f7fffffe          BL       USART_ITConfig
;;;259    	USART_Cmd(USART2, ENABLE);
000084  2101              MOVS     r1,#1
000086  4803              LDR      r0,|L7.148|
000088  f7fffffe          BL       USART_Cmd
;;;260    }
00008c  b005              ADD      sp,sp,#0x14
00008e  bd00              POP      {pc}
;;;261    
                          ENDP

                  |L7.144|
                          DCD      0x40011400
                  |L7.148|
                          DCD      0x40004400

                          AREA ||.data||, DATA, ALIGN=0

                  sendbuf
000000  01020304          DCB      0x01,0x02,0x03,0x04
000004  05                DCB      0x05
                  datanum
000005  05                DCB      0x05
